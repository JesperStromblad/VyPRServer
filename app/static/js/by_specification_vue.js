var code_highlight_palette = ["#cae2dc", "#eee3cd", "#cad7f2", "#ded4e7", "#e3e3e3", "d6eff0"];
//var code_highlight_palette = ["red", "blue", "green"];
// global plot data, used for when plot are updated with new data
var plot_visible = false;
var plot_data = null;
var selected_binding = undefined;
var Store = {
    status : {
        loading : false,
    },
    plot : {
        constraint_html : "",
        type : null,
        show_violations : true,
        show_successes : true,
        current_hash : null
    },
    selected_calls : [],
    binding_selected : false,
    subatom_selected : false
};

var start_loading = function() {
    Store.status.loading = true;
}

var stop_loading = function() {
    Store.status.loading = false;
}

var decodeHTML = function (html) {
  var txt = document.createElement('textarea');
  txt.innerHTML = html;
  return txt.value;
}

var html_space_replace = function(){
  var leadingSpaces = arguments[0].length;
  var str = '';
  while(leadingSpaces > 0) {
    str += '&nbsp;';
    leadingSpaces--;
  }
  return str;
}

var subatom_click = function(dict){app.$emit("subatom-selected", dict)};

var generate_plot = function(root_obj) {
    var that = root_obj;
    // get the plot type
    var type = Store.plot.type;
    // set global plot data
    // this is used when function calls are selected - if a plot is already being shown,
    // the new data will be merged into the plot
    plot_visible = true;
    // get global plot data
    var data = plot_data;
    // first case: the selected option was to plot verdict severity at a point generated by a simple atom
    if (type == "severity" || type == "observation"){
      axios.post('/get_plot_data_simple/', data).then(function(response){
        var data = response.data.plot_data;
        Store.plot.current_hash = response.data.plot_hash;
        // perform necessary processing on data before plotting
        console.log(JSON.stringify(data));

        var myData = [{key: 'group 1', values: []}];
        for (var i=0; i<data["x"].length; i++){
          var value = data[type][i];
          // check whether we should plot this based on the filters
          if(value >= 0) {
            if(!Store.plot.show_successes) continue;
          } else {
            if(!Store.plot.show_violations) continue;
          }
          if(type == "severity") {
            // negative verdict severity represents violation - colour these bars red
            var color = "#cc0000";
            // other columns in the plot are green since they show non-violating observations
            if (value >= 0) {color = "#00802b"}
          } else {
            color = "blue";
          }
          myData[0].values.push({label: new Date(Date.parse(data["x"][i])),
                                value: value,
                                color: color});
        }

        // emit plot data ready event so the plot will be drawn
        that.$root.$emit("plot-data-ready", myData);
        start_loading();
      });
    }
    if (type == "between-severity" || type == "between-observation"){
      axios.post('/get_plot_data_between/', data).then(function(response){
        var data = response.data.plot_data;
        Store.plot.current_hash = response.data.plot_hash;

        var myData = [{key: 'group 1', values: []}];
        for (var i=0; i<data["x"].length; i++){
          var value = data[type][i];
          // check whether we should plot this based on the filters
          if(value >= 0) {
            if(!Store.plot.show_successes) continue;
          } else {
            if(!Store.plot.show_violations) continue;
          }
          if(type == "between-severity") {
            // negative verdict severity represents violation - colour these bars red
            var color = "#cc0000";
            // other columns in the plot are green since they show non-violating observations
            if (value >= 0) {color = "#00802b"}
          } else {
            color = "blue";
          }
          myData[0].values.push({label: new Date(Date.parse(data["x"][i])),
                                value: value,
                                color: color});
        }

        // emit plot data ready event so the plot will be drawn
        that.$root.$emit("plot-data-ready", myData);
        start_loading();
      })
    }
};

Vue.use(VuejQueryMask);

Vue.component("alert", {
  template : `
  <div class="alert alert-info alert-dismissible" role="alert" v-if="is_open">
    <button type="button" class="close" data-dismiss="alert" aria-label="Close" @click="close()">
      <span aria-hidden="true">&times;</span>
    </button>
    {{ message }}
  </div>
  `,
  props : ["message"],
  data : function() {
    return {
      is_open : true
    }
  },
  methods : {
    close : function() {
      this.is_open = false;
    }
  }
});


Vue.component("loading-spinner", {
  template : `
  <div class="loading-spinner" role="status" v-if="in_progress"></div>
  `,
  data : function() {
    return {
      store : Store
    }
  },
  computed : {
    in_progress : function() {
      return this.store.status.loading;
    }
  }
});


Vue.component("machine-function-property", {
  props: ['tree'],
  template : `
    <div class="panel panel-success">
      <div class="panel-heading">
        <h3 class="panel-title" id="function-title" @click="showFunctions=!showFunctions">
            Machine / Function / Property
        </h3>
      </div>
      <div class="panel-body">
        <alert message="Select a specification to see relevant calls." />
        <transition name="slide-fade">
        <div v-show="showFunctions" class="list-group" id="function-list">
          <div id="function-list-data"></div>
          <div class="tab">
            <button v-for="(value,key) in tree" :class="(key===showTab)? 'tablinks active':'tablinks' "
                @click="selectTab(key)">
                {{key}}
            </button>
          </div>
          <subtree v-for="(value,key) in tree" v-show="(key === showTab)"
            :key="key" :id="key" :content="value">
          </subtree>
        </div>
        </transition>
      </div>
    </div>`,
  data() {
    return {showTab: "", showFunctions: true}
  },
  methods : {
    selectTab: function(selectedTab){
      // selectedTab contains the ID of the tabcontent element which needs to be displayed
      this.showTab = selectedTab;
    }
  },
  mounted() {
    // all tabs except for the one whose ID is == showTab are hidden
    // store the ID of the first tab so that it gets displayed
    var machine_keys=[];
    for (key in this.tree){
      machine_keys.push(key)
    }
    this.selectTab(machine_keys[0]);
    var remember_this = this;
    this.$root.$on('function-select', function(dict){
      // after selecting a function (specification), hide functions list to make space for calls
      remember_this.showFunctions = false;
    })
  }
})


Vue.component("subtree",{
  props: ['id', 'content'],
  template:  `
    <div class="tabcontent" :id=this.tabid>
      <subtreelevel :htmlcontent="content" :path="id"> </subtreelevel>
    </div>`,
  data() {
    return { tabid: "tab-" + this.id }
  }
})


Vue.component("subtreelevel", {
  /*recursive component, properties store the following information:
  htmlcontent - function tree based on which the html of the element is built, updated for each level
  path - the path through the function tree to the current element
  panelid, stylepadding - strings which are used to define the header on each level
  keyname - title in the header, taken as a dictionary key on the current tree level

  after adding the header for the current level, iterate through the lower level to repeat the process
  if the subtreelist is empty, this is an indicator that we reached the last level
  - this means it is time to display the specification - the recursion stops here*/
  props: ['htmlcontent', 'path', 'panelid', 'stylepadding', 'keyname'],
  template: `
    <div class="panel panel-default" style="inherit">
      <div v-if="keyname" class="panel-heading">
        <h3 class="panel-title" :id="this.panelid" :style="this.stylepadding"> {{this.keyname}} </h3>
      </div>
      <div class="panel-body">
        <div class="list-group" :id="path">
          <subtreelevel v-for="(level,index) in this.subtreeslist" :key="index" :htmlcontent="level.nextcontent"
          :path="level.nextpath" :panelid="level.panelid" :stylepadding="level.stylepadding"
          :keyname="level.keyname"></subtreelevel>
          <div v-if="!this.subtreelist">
            <button v-for="(b, index) in this.buttons" type="button" class="list-group-item"
              :function-id="b.functionid" :style="b.padding" @click="selectFunction(b.functionid, b.str)">
              <specification :spec=b.str :change="0"></specification>
            </button>
          </div>
        </div>
      </div>
    </div>
    `,
  data() {
    // take subtree and path from properties parsed to this component
    var subtree = JSON.parse(JSON.stringify(this.htmlcontent));
    var path = this.path;
    var padding = String(path.split("-").length * 20) + "px";

    // check if the last level is reached - if it is, return an empty subtrees list to indicate this
    // also return the HTML needed to build the element with the specification
    if(Array.isArray(subtree)) {
      var buttons = [];
      for(var i=0; i<subtree.length; i++) {
        var str = subtree[i][2];
        //str = decodeHTML(str);
        buttons.push({functionid: subtree[i][0], padding : "padding-left:" + padding, str : str});
      }
      return {buttons: buttons, subtreeslist:[]}

    // if this is not the last level, iterate through the keys in the subtree and return the list
    // based on which new subtree components will be defined
    } else {
      var keys = [];
      for (var key in subtree) {
        keys.push(key);
      }
      console.log("path="+path+"; keys="+ keys);

      var dicts_list = [];
      for(var i=0; i<keys.length; i++) {
        var key = keys[i];
        // create list inside the current list in the dom
        var new_path = (path != "") ? (path + "-" + key) : key;
        var panel_id = "external-" + new_path;
        var style_padding = "padding-left: " + padding;

        dicts_list.push({keyname: key,
          nextcontent : subtree[key], nextpath : new_path,
          stylepadding : style_padding, panelid : panel_id});
      }
      return {subtreeslist : dicts_list}
    }
  },
  methods : {
    selectFunction: function(id, code){
      console.log(id);
      start_loading();
      this.$root.$emit('function-select', {selected_function_id: id, specification_code: code})
    }
  }
})


Vue.component("function-calls", {
  template : `
    <div class="panel panel-success">
      <div class="panel-heading">
        <h3 class="panel-title" id="function-call-title">Function Call</h3>
      </div>
      <div class="panel-body">
        <div class="list-group" id="function-call-list">
          <div v-if="message" class="please-select"><p>{{message}}</p></div>
          <alert v-if="!message" message="Select one or more calls to load performance data." />
          <div v-if="!message" class="list-group-item">
            <b>From</b> <vue-mask id="filter-from" v-model="filter_from" mask="00/00/0000 00:00:00"
                         placeholder="DD/MM/YYYY hh:mm:ss" :raw="false"> </vue-mask>
            <b>To</b> <vue-mask id="filter-to" v-model="filter_to" mask="00/00/0000 00:00:00"
                       placeholder="DD/MM/YYYY hh:mm:ss" :raw="false"> </vue-mask>
            <button @click="select_filtered()"> Filter calls </button>
          </div>
          <button v-if="!message" class="list-group-item">
            <input type='checkbox' id="select-all" @click="select_all_calls()"/><b> Select all </b>
          </button>
          <button v-for="(b, index) in this.buttons" :key="index" class="list-group-item">
            <input type='checkbox' :function-call-id="b.callid" :value="b.callid" v-model="checkedCalls"/>
            <b>Start:</b> {{b.callstart}}, <b>lasting: </b> {{b.callduration}} seconds
          </button>
        </div>
      </div>
    </div>`,
  data() {
    return {
      message : "Select a function first.",
      buttons : [],
      checkedCalls: [],
      filter_from: "",
      filter_to: "",
      func_id: 0,
      store : Store}
  },
  methods: {
    select_all_calls: function(){
      start_loading();
      var is_checked = $("#select-all").prop("checked");
      $("input:checkbox").prop("checked", is_checked);
      if (is_checked) {
        for(var i=0; i<this.buttons.length; i++){
          this.checkedCalls.push(this.buttons[i].callid);
        }
      }
      else {
        this.checkedCalls = [];
      }
      // display only relevant alerts
      Store.binding_selected = false;
      Store.subatom_selected = false;

      stop_loading();

    },
    select_filtered: function(){
      start_loading();

      $("input:checkbox").prop("checked", false);
      this.checkedCalls = [];
      var time = {function: this.func_id, from: this.filter_from, to: this.filter_to};
      var that = this;

      axios.post("/list_calls_between/", time).then(function(response){
        var ids_list = response.data;
        console.log(ids_list.length);
        var calls_list = $("input:checkbox");
        for (var i=0; i<that.buttons.length; i++){
          if (that.buttons[i].callid == ids_list[0]){
            for (var j=i; j<i+ids_list.length; j++){
              that.checkedCalls.push(that.buttons[j].callid);
              $(calls_list[j+1]).prop("checked", true);
            }
            break
          }
        }
      })
      stop_loading();
    }
  },
  mounted(){
    var obj = this;
    this.$root.$on('function-select', function(dict){
      // when a specification is selected, get the calls list from server
      // while it's loading, display a temporary message
      // since each call has an input checkbox, we need to catch any changes in the selection

      obj.message = "Loading function calls.  This can take some time if there are many.";
      obj.buttons = [];
      obj.checkedCalls = [];
      obj.func_id = dict["selected_function_id"];

      axios.get('/list_function_calls/'+obj.func_id).then(function(response){
        var data = response.data["data"];
        obj.message = "";
        var buttons_list = [];
        var i;
        for(i=0; i<data.length; i++) {
          var button = {callid : data[i][0], callstart: data[i][2], callduration: data[i][6]}
          buttons_list.push(button)
        }
        obj.buttons = buttons_list;
        obj.filter_from = buttons_list[0].callstart;
        obj.filter_to = buttons_list[i-1].callstart;

        obj.$root.$emit('calls-loaded', dict);
      })
    })
  },
  watch: {
    checkedCalls: function(value){
      console.log(value)
      var function_call_ids = [];
      var that = this;
      for (var i=0; i<value.length; i++){
        function_call_ids.push(""+value[i]);
      }

      Store.selected_calls = function_call_ids;
      if (!plot_visible) {
        // display code interface
        if (function_call_ids.length){
          axios.post("/get_function_calls_data/", {"ids" : function_call_ids}).then(function(response) {
            tree = response.data;
            console.log(JSON.stringify(tree))
            that.$root.$emit('calls-selected',tree);
          });
        }
      } else {
        // add data to plot without displaying code interface
        plot_data.calls = function_call_ids;
        // trigger plotting
        generate_plot(this);
      }
    }
  }
})


Vue.component("code-view", {
  /* This is the most complex component. It is empty at the beginning, but upon the selection
  of the function and the calls, some data is displayed. When the user selects a function,
  the specification and the source code of the selected function are shown. Additionally,
  the lines in the code that quantifiers in the specification refer to are highlighted.
  When the calls are also selected, more data is displayed and some code lines are hidden.*/
  template : `
    <div class="panel panel-success">
      <div class="panel-heading">
        <h3 class="panel-title">Code View</h3>
      </div>
      <div class="panel-body" id="verdict-list">
        <div v-if="message" class="please-select">{{message}}</div>
        <alert v-if="binding_is_selected"
            message="Select a part of the specification to narrow down critical statements in the code." />
        <div v-if="specification_code" id='specification_listing'>
          <specification :spec="this.specification_code" :change="1" />
        </div>
        <plot></plot>
        <div v-if="code_lines" class='code_listing' id="code-listing">
          <alert v-if="calls_are_selected" message="Select a binding in the code listing below." />
          <alert v-if="subatom_is_selected" message="Hover over a critical statement to see analysis options." />
          <div v-for="(line,index) in code_lines" :key="index" :class="line.class"
          :id="line.id" :style="line.background" :save-background-color="line.color"
          v-show="line.show">
            <b> {{line.line_number}} </b> <span v-html="line.content"> </span>
            <span class="span-binding" :id="line.spanid"><button v-for="b in line.buttons"
            class="binding-button" :binding-button="b.binding" :style="b.font"
            @click="selectBinding(b.binding, b.subtree, b.lines)">
            binding {{b.binding}}</button></span>
            <p v-show="line.showempty" class="empty-line" :id="line.emptyid"><b> ... </b><br> </p>
            <dropdown v-if="line.addmenu" :tree="this.tree" :dict="line.dict" :binding="this.binding"
            :line=line.line_number @firstselected="selectOther($event)"> </dropdown>
          </div>
        </div>
      </div>
    </div>`,
  data(){
    return {
      message: "Select a function and then one or more calls, first.",
      specification_code: "",
      code_lines: [],
      start_line: 0,
      tree: {},
      binding: undefined,
      store : Store}
  },
  computed : {
    calls_are_selected : function() {
      return this.store.selected_calls.length > 0;
    },
    binding_is_selected : function() {
      return this.store.binding_selected;
    },
    subatom_is_selected : function() {
      return this.store.subatom_selected;
    }
  },
  methods:{
    selectBinding : function(binding, tree, lines){
      // binding stores the index of the binding, tree is the branch tree[binding]
      // lines is a list of line numbers that need to be highlighted

      var whole_code = this.code_lines;
      var start_line = this.start_line;

      // reset the background colors of previously highlighted lines
      for (var i=0; i<whole_code.length; i++){
        var line = whole_code[i];
        line.addmenu = false;
        line.class = "code_listing_line";
        if (line.color){
          line.background = "background-color: #ebf2ee";
        }
        for (var j=0; j<line.buttons.length; j++){
          if (line.buttons[j].binding == binding){
            line.buttons[j].font = "font-weight: bold";
          }
          else{
            line.buttons[j].font = "font-weight: normal";
          }
        }
      }

      for (var i=0; i<lines.length; i++){
        var line = whole_code[lines[i]-start_line];
        line.background = "background-color: " + line.color;
      }
      this.binding = binding;
      selected_binding = binding;
      this.tree = tree;
      this.$root.$emit("binding-selected", tree);
    },
    selectOther : function(list){
      for (var i=0; i<list.length; i++){
        var index = list[i]["line"]-this.start_line;
        var line = this.code_lines[index];

        line.background = "background-color: " + line.color;
        line.dict = "select-other";
        line.addmenu = true;
        line.class = "code_listing_line code_listing_line-clickable";
      }
    }
  },
  mounted(){
    var obj2 = this;
    this.$root.$on('calls-loaded', function(dict){
      start_loading();
      obj2.message = "";
      obj2.specification_code = dict["specification_code"];
      axios.get('/get_source_code/'+dict["selected_function_id"]).then(function(response){
        var code_data = response.data;
        var code_lines = code_data["code"];
        var current_line = code_data["start_line"];
        obj2.start_line = current_line;

        // we also want to display binding reference at the end of each line
        // first, go through bindings and collect all line numbers they refer to
        var bindings_list = code_data["bindings"];
        var line_numbers = [];
        for (var i=0; i<bindings_list.length; i++){
          binding = bindings_list[i];
          line_numbers = line_numbers.concat(binding["binding_statement_lines"]);
        }

        // add each line as a div element, if it is in the list of binding statement lines,
        // also add a span element to the content of the line - later, we will add binding labels to it
        var lines_list = [];
        for(var i=0; i < code_lines.length; i++) {
          var line_text = code_lines[i].replace(/\t/g, "&nbsp;&nbsp;&nbsp;").replace(/^[ \t]+/mg, html_space_replace);
          var line_div = {line_number: current_line, id: "line-number-" + current_line,
                          background: "background-color: transparent", color: "", show: true,
                          added_empty_line: false, spanid: "span-bindings-line-" + current_line,
                          content: line_text, buttons: [], emptyid: "empty-line-" + current_line,
                          showempty: false, addmenu: false, class: "code_listing_line", dict: {}}


          lines_list.push(line_div);
          current_line++;
        }

        obj2.code_lines = lines_list;


        // we want to highlight the quantification in the specification code
        // with the same color as the line of code it refers to
        var quantification_ids = obj2.specification_code["vars"].split(", ");

        // for each binding line go through the specification to find the quantification
        // that refers to that line and highlight it the same color as the line in the code
        for (var i=0; i<bindings_list.length; i++){
          var binding = bindings_list[i];
          var line_numbers = binding["binding_statement_lines"];

          for (var j=0; j<line_numbers.length; j++){
            var no = line_numbers[j]
            var color = code_highlight_palette[j];
            lines_list[no-code_data["start_line"]].background = "background-color: "+color;
            lines_list[no-code_data["start_line"]].color = color;
            //$("#span-bindings-line-"+no).append(" "+binding["id"]);
          } //end j-loop
        } //end i-loop
        stop_loading();
      })
    })
    this.$root.$on('calls-selected', function(tree){
      obj2.tree = tree;

      var show_lines = []; //stores all lines that are of interest plus a few around them - we will hide the rest
      var start_line = obj2.start_line;
      var whole_code = obj2.code_lines;

      //clean up the binding buttons and dropdown menus from previous selection
      for (var i=0; i<whole_code.length; i++){
        whole_code[i].buttons = [];
        whole_code[i].addmenu = false;
        whole_code[i].class = "code_listing_line";
      }

      // iterate through the bindings to highlight the lines and separate those paired with
      // a quantifier from those that are of interest because a subatom generates observations there
      for (binding in tree){
        var line_numbers = []; //stores all points of interest
        var lines_points = []; //stores only those stored by bindings
        for (atom in tree[binding]){
          for (subatom in tree[binding][atom]){
            list = tree[binding][atom][subatom];
            for (var i=0; i<list.length; i++){
              if (line_numbers.indexOf(list[i]["code_line"])==-1){
                line_numbers.push(list[i]["code_line"]);
              }
              if (atom=="-1" && lines_points.indexOf(list[i]["code_line"])==-1){
                lines_points.push(list[i]["code_line"]);
              }

            }
          }
        }
        show_lines = show_lines.concat(line_numbers);
        for (var i=0; i<line_numbers.length; i++){
          var no = line_numbers[i] - obj2.start_line;
          whole_code[no].background = "background-color: #ebf2ee"
          color = whole_code[no].color;
          if (!(color)){
            whole_code[no].color = "#def1fc";
          }
        }
        for (var i=0; i<lines_points.length; i++){
          var no = lines_points[i];
          whole_code[no-start_line].buttons.push({binding: binding, subtree: tree[binding],
            lines: line_numbers, font: "font-weight: normal"});
          }
        }

      show_lines = show_lines.sort();

      //in addition to the lines stored in leaves, we want to display the first line
      // and in this case, three lines around each instrumentation point
      var more_lines = [obj2.start_line];
      for (var i=0; i<show_lines.length; i++){
        var current_line_number = show_lines[i];
        for (var j=1; j<3; j++){
          more_lines.push(current_line_number+j);
          more_lines.push(current_line_number-j)
        }
      }
      show_lines = show_lines.concat(more_lines);

      for (var i=0; i<whole_code.length; i++){
        var line_id = whole_code[i].id.split("-");
        var id_line_number = line_id[line_id.length-1];
        if (show_lines.indexOf(parseInt(id_line_number))==-1){
          whole_code[i].show = false;
        }
        else{
          whole_code[i].show = true;
        }
      }

      // insert a spacing where there is a jump in line numbers
      show_lines = show_lines.sort(function(a, b){return a - b});

      for (var i=0; i<show_lines.length; i++){
        if (show_lines[i] < (show_lines[i+1] - 1)){
          whole_code[show_lines[i]-obj2.start_line].showempty = true;
        }
        else{
          whole_code[show_lines[i]-obj2.start_line].showempty = false;
        }
      }
    })
    this.$root.$on("subatom-selected", function(dict){
      /* For selected calls, binding, and subatom, highlight the lines that represent
      instrumentation points monitored during those calls and at which observation were
      generated by the selected subatom. In addition to highlighing those lines, we also want
      to be able to select them as instrumentation point and fetch some data about the
      corresponding observations and verdicts in order to visualise the performance analysis results.
      The visualisation options are given within a dropdown menu.
      */
      var atom_index = dict["atom"];
      var sub_index = dict["subatom"];
      var inst_points_list = obj2.tree[atom_index][sub_index];
      var whole_code = obj2.code_lines;

      var lines_list = [];
      for (var i=0; i<inst_points_list.length; i++){
        var no = inst_points_list[i]["code_line"];
        //$("#line-number-"+no).attr('save-background-color',color);
        lines_list.push(no);
      }

      // clean up any previous dropdowns and reset highlights back to a light colour
      // reset the class of the line back to non-clickable
      for (var i=0; i<whole_code.length; i++){
        if (whole_code[i].color) {
          whole_code[i].background = "background-color: #ebf2ee";
          whole_code[i].addmenu = false;
          whole_code[i].class = "code_listing_line";
        }
      }

      // now highlight and add dropdowns to the lines in lines_list
      for (var i=0; i<lines_list.length; i++){
        var line = whole_code[lines_list[i]-obj2.start_line]
        line.background = "background-color: " + line.color;
        line.addmenu = true;
        line.class = "code_listing_line code_listing_line-clickable";
        line.dict = dict;
      }
    })
  }
})


Vue.component("specification", {
  /* this component is still jquery reliant as a part of its HTML (atom and subatom span elements)
  is received from the server side instead of being generated within the template*/
  props: ['spec', 'change'],
  template: `
    <div>
      <p v-for="(v, index) in this.bindvars" class="list-group-item-text code" :id="v.id" v-html="v.forall"
          :style="v.background"> </p>
      <p class="list-group-item-text code">Check( </p>
      <p class="list-group-item-text code" v-html="this.vars"></p>
      <p class="list-group-item-text code" v-html="this.str"></p>
      <p class="list-group-item-text code">&nbsp;&nbsp;) </p>
      <p class="list-group-item-text code">)</p>
    </div>`,
  data(){
    var spec_dict = this.spec;
    var list = spec_dict["foralls"];
    var bindvars = [];
    for (i=0; i<list.length; i++){
      var bg;
      if (this.change==1){
        bg = "background-color: " +
          code_highlight_palette[spec_dict["vars"].split(", ").indexOf(list[i]["var_id"])] + ";";
      }
      else{
        bg = "background-color: transparent;";
      }
      bindvars.push({id: list[i]["var_id"],
                     forall: "Forall("+list[i]["var_forall"]+").\\ ",
                     background: bg})
    }
    return {
      vars : "&nbsp;&nbsp;lambda " + spec_dict["vars"] + " : (",
      str : "&nbsp;&nbsp;&nbsp;&nbsp; " + spec_dict["atom_str"],
      bindvars: bindvars
    }
  },
  watch: {
    // when a new specification is selected, the specification listing in the code view component
    // must also change - watch for this change and change the data to trigger the rerendering
    spec(newValue) {
      var spec_dict = newValue;
      var list = spec_dict["foralls"];
      var bindvars = [];
      for (i=0; i<list.length; i++){
        var bg;
        if (this.change==1){ bg = "background-color: " +
            code_highlight_palette[spec_dict["vars"].split(", ").indexOf(list[i]["var_id"])] + ";";}
        else { bg = "background-color: transparent;";}
        bindvars.push({id: list[i]["var_id"],
                       forall: "Forall("+list[i]["var_forall"]+").\\ ",
                       background: bg})
      }
      this.vars = "&nbsp;&nbsp;lambda  : ( " + spec_dict["vars"];
      this.str = "&nbsp;&nbsp;&nbsp;&nbsp; " + spec_dict["atom_str"];
      this.bindvars = bindvars;
    }
  },
  mounted(){
    var that = this;
    this.$root.$on('calls-loaded', function(tree){
      // clean up subatom links from previous function selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");
    })

    this.$root.$on('calls-selected', function(tree){
      // clean up subatom links from previous binding selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");
    })

    this.$root.$on('binding-selected', function(tree){
      Store.binding_selected = true;
      // clean up subatom links from previous binding selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");

      // highlight the atoms that generated observations for the selected calls and binding
      // make subatoms clickable - global function subatom_click() will then emit event
      // so that other components can react to the subatom selection
      for (atom in tree){
        var subtree = tree[atom];
        var subs = $($("#specification_listing").find('span.atom[atom-index="' + atom + '"]')[0]).find("span.subatom");
        for (var i=0; i<subs.length; i++){
          $(subs[i]).attr('class', "subatom-clickable");
          $(subs[i]).attr('subtree', JSON.stringify(subtree));
          var dict = {atom: atom, subatom: $(subs[i]).attr("subatom-index")};
          $(subs[i]).attr('onclick', 'subatom_click('+JSON.stringify(dict)+')');
        }
      }
    })

    this.$root.$on("subatom-selected", function(dict){
      // when a subatom is selected, change its class to active - this affects its style
      $($(".subatom-clickable-active")[0]).attr("class", "subatom-clickable");
      var subatom = $(
        $("#specification_listing").find('span.atom[atom-index="' + dict["atom"] + '"]'
      )[0]).find(
        'span[subatom-index="'+dict["subatom"]+'"]'
      )[0];
      $(subatom).attr("class", "subatom-clickable-active");
      // update global state
      Store.plot.constraint_html = decodeHTML($($(".subatom-clickable-active")[0]).parent().html());
      Store.subatom_selected = true;
    })
  }
})


Vue.component("dropdown", {
  // is displayed when hovering above the corresponding line in the code
  // requires data about all the previously selected levels in order to get the filtered verdict
  // and observation values from the server
  props: ["tree", "dict", "binding", "line"],
  template: `
    <div class="dropdown-content">
      <p v-for="option in this.options" class="dropdown-menu-option" @click="selectOption(option.data)">
        {{option.text}} </p>
    </div>
  `,
  data(){
    // dict will contain string "select-other" instead of atom and subatom indices if
    // the menu is a child of a line selected as the second one in a pair (timeBetween atom)

    if (this.dict == "select-other"){
      var new_list = [];
      for (var i=0; i<plot_data["other_lines"].length; i++){
        if (plot_data["other_lines"][i]["line"] == this.line){
          new_list.push(plot_data["other_lines"][i]["id"]);
        }
      }
      return {options: [{text: "Fix this point as the other one and plot observations",
                         data: {action: "between-observation-plot",
                                type : "between-observation",
                                new_points: new_list}},
                        {text: "Fix this point as the other one and plot severity",
                         data: {action: "between-severity-plot",
                                type : "between-severity",
                                new_points: new_list}}]}
    }

    // if dict is not a string, proceed as if the dropdown is generated to select the first point

    var options = [];
    var atom_index = this.dict["atom"];
    var sub_index = this.dict["subatom"];
    var inst_points = this.tree[selected_binding][atom_index][sub_index];
    var inst_point_id = inst_points[0]["id"];
    var that = this;

    var inst_points_list = [];
    for (var i=0; i<inst_points.length; i++){
      if (inst_points[i]["code_line"] == this.line){
        inst_points_list.push(inst_points[i]["id"]);
      }
    }

    // the options in the menu depend on the type of the atom that contains the selected subatom

    axios.get('/get_atom_type/'+atom_index+"/"+inst_point_id+"/").then(function(response){
      var atom_type = response.data;
      console.log(atom_type);
      if (atom_type == "simple"){
        //for a simple atom we now need all observations made at these points,
        //filtered by: calls, binding, atom, subatom
        //then we can calculate verdict severity for each of the observations
        var option = {text: 'Plot severity of observations from this point',
                      data: {action: "simple-severity-plot",
                             type : "severity",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
         var option = {text: 'Plot observations from this point',
                      data: {action: "simple-observation-plot",
                             type : "observation",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
        var option2 = {text: 'Highlight paths by average verdict severity',
                      data: {action: "simple-path",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option2);
      }
      else if (atom_type == "timeBetween") {
        // we need the list of inst points that belong to the same atom, but other than the selected subatom
        var other_points_list = [];
        var subtree = that.tree[selected_binding][atom_index];
        for (subatom in subtree){
          if (subatom != sub_index){
            for (var i=0; i<subtree[subatom].length; i++){
              other_points_list.push({id: subtree[subatom][i]["id"],
                                      line: subtree[subatom][i]["code_line"]});
            }
          }
        }
        option = {text: 'Fix this point and select the other one',
                  data: {action: "between-select",
                         type : "between-select",
                         other_lines: other_points_list,
                         calls: Store.selected_calls,
                         binding: selected_binding,
                         atom: atom_index,
                         points: inst_points_list}};
        options.push(option);
      }
      else if (atom_type == "mixed") {
        option = {text: 'Fix this point and select the other one', data:{}};
        options.push(option);
      }
    })
    return{options: options}
  },
  methods: {
    selectOption: function(data){
      start_loading();
      if (data["action"] == "simple-severity-plot"){
        // set the plot data globally
        plot_data = data;
        // set the plot type
        Store.plot.type = "severity";
        // plot the data we just set
        generate_plot(this);
      }
      if (data["action"] == "simple-observation-plot"){
        // set the plot data globally
        plot_data = data;
        // set the plot type
        Store.plot.type = "observation";
        // plot the data we just set
        generate_plot(this);
      }
      if (data["action"] == "between-select") {
        plot_data = data;
        this.$emit("firstselected", data["other_lines"]);
      }
      else if (data["action"] == "between-observation-plot") {
        plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        Store.plot.type = "between-observation";
        generate_plot(this);
      }
      else if (data["action"] == "between-severity-plot") {
        plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        Store.plot.type = "between-severity";
        generate_plot(this);
      }
      // TODO
      if (data["action"] == "simple-path") {}
      if (data["action"] == "mixed-select") {}

      stop_loading();
    }
  }
})


Vue.component("plot", {
  template: `<div id="plot-wrapper" class="plot">
  <div id="plot-controls"><a href="#" @click="hidePlot($event)" class="close-plot">close</a></div>
  <div id="plot-new-window">
    <p><a href="#" @click="newPlotWindow($event)">Move to new window</a></p>
    <p><a href="#" @click="downloadPDF($event)">Download PDF</a></p>
  </div>
  <div id="plot-description" v-html="this.description"></div>
  <div id="plot-filters" v-if="is_severity_plot">Filters:
    <a href="#" id="violations" class="filter" v-bind:class="{active : violationFilterActive}"
      @click="toggleViolationFilter($event)">Violations</a>
    <a href="#" id="successes" class="filter" v-bind:class="{active : successFilterActive}"
      @click="toggleSuccessFilter($event)">Successes</a>
  </div>
  <svg id="plot-svg"></svg>
  </div>`,
  data() {
    return {
      store : Store
    }
  },
  computed : {
    description : function() {
      if(this.store.plot.type == "severity" || this.store.plot.type == "between-severity") {
        return 'Plot of <span class="constraint">' + this.store.plot.constraint_html + "</span> severity";
      } else {
        return 'Plot of <span class="constraint">' + this.store.plot.constraint_html + "</span>";
      }
    },
    violationFilterActive : function() {
      return this.store.plot.show_violations;
    },
    successFilterActive : function() {
      return this.store.plot.show_successes;
    },
    is_severity_plot : function() {
      return this.store.plot.type == "severity" || this.store.plot.type == "between-severity";
    }
  },
  mounted(){
    var that = this;
    this.$root.$on("calls-loaded", function(dict){
      if (!(plot_visible)) return
      // empty plot
      $("#plot-svg").empty();
      // toggle visibility
      $("#plot-wrapper").removeClass("show");
      // set the global flag
      plot_visible = false;
    })
    this.$root.$on("plot-data-ready", function(data_array){
      // display the plot
      $("#plot-wrapper").addClass("show");
      // set height of plot wrapper
      $("#plot-wrapper").height($("#code-listing").outerHeight() + 10);
      $("#plot-svg").width($("#code-listing").outerWidth());
      if(that.store.plot.type == "severity") {
          $("#plot-svg").height($("#code-listing").outerHeight() - $("#plot-controls").outerHeight()
                                - $("#plot-description").outerHeight()
                                - $("#plot-filters").outerHeight());
      } else {
          $("#plot-svg").height($("#code-listing").outerHeight() - $("#plot-controls").outerHeight()
                                - $("#plot-description").outerHeight());
      }
      //var data_array = data["array"];
      nv.addGraph(function() {
        var chart = nv.models.multiBarChart()
          .x(function(d) { return d.label })
          .y(function(d) { return d.value })
          .reduceXTicks(true)    //alternatively, use staggering or rotated labels to prevent overlapping
          .showControls(false);

        // omitting date from time format - moslty the difference is in seconds
        chart.xAxis
          .axisLabel('Time of observation')
          .tickFormat(function(d) { return d3.time.format('%H:%M:%S')(new Date(d)); });
        chart.yAxis
          .axisLabel('Verdict severity')
          .tickFormat(d3.format('.02f'))
          .showMaxMin(true);

        d3.select('#plot-svg')
          .datum(data_array)
          .call(chart);

        nv.utils.windowResize(chart.update);

        // set initial size
        chart.update();

        stop_loading();

        return chart;
      });
    })
  },
  methods:{
    hidePlot: function(e){
      // prevent navigation that would normally take place when a link is clicked
      e.preventDefault();
      // empty plot
      $("#plot-svg").empty();
      // toggle visibility
      $("#plot-wrapper").toggleClass("show");
      // set the global flag
      plot_visible = false;
    },
    newPlotWindow : function(e) {
      e.preventDefault();
      $("#plot-svg").empty();
      $("#plot-wrapper").toggleClass("show");
      plot_visible = false;
      window.open("/display_plot/" + this.store.plot.current_hash, "plot", "height=500,width=900");
    },
    downloadPDF : function(e) {
      e.preventDefault();
      window.location = "/download_plot/" + this.store.plot.current_hash;
    },
    toggleSuccessFilter : function(e) {
      e.preventDefault();
      this.store.plot.show_successes = !this.store.plot.show_successes;
      generate_plot(this);

    },
    toggleViolationFilter : function(e) {
      e.preventDefault();
      this.store.plot.show_violations = !this.store.plot.show_violations;
      generate_plot(this);
    }
  }


})


var app = new Vue({
    el : "#app"
});
