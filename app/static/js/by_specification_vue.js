var code_highlight_palette = ["#89c6d9", "#a1cc87", "#f0ad95", "#ded4e7", "#e3e3e3", "d6eff0"];
//var code_highlight_palette = ["red", "blue", "green"];
// global plot data, used for when plot are updated with new data
var plot_visible = false;
var path_visible = false;
var plot_data = null;
var path_plot_data = null;
var path_plot_hash = null;
var selected_binding = undefined;
var sidebar_scroll_timeout = null;
var path_highlight_mode_on = false;
var Store = {
  status : {
    loading : false,
  },
  plot : {
    constraint_html : "",
    type : null,
    show_violations : true,
    show_successes : true,
    current_hash : null
  },
  selected_calls : [],
  selected_tests: [],
  selected_property_hash : null,
  binding_selected : false,
  subatom_selected : false,
  first_point_selected : false,
  type_of_atom : undefined,
  tests_exist : null,
  current_tab : null,
  path_view : false,
  chosen_path_index : 0
};

var start_loading = function() {
  Store.status.loading = true;
}

var stop_loading = function() {
  Store.status.loading = false;
}

var decodeHTML = function (html) {
  var txt = document.createElement('textarea');
  txt.innerHTML = html;
  return txt.value;
}

var html_space_replace = function(){
  var leadingSpaces = arguments[0].length;
  var str = '';
  while(leadingSpaces > 0) {
    str += '&nbsp;';
    leadingSpaces--;
  }
  return str;
}

var subatom_click = function(dict){
  Store.first_point_selected = false;
  app.$emit("subatom-selected", dict)
};

var generate_plot = function(root_obj) {
  var that = root_obj;
  // get the plot type
  var type = Store.plot.type;
  // set global plot data
  // this is used when function calls are selected - if a plot is already being shown,
  // the new data will be merged into the plot
  // plot_visible = true;
  // get global plot data
  var data = plot_data;

  console.log("storing plot data");
  console.log(data);

  // first case: the selected option was to plot verdict severity at a point generated by a simple atom
  if (type == "severity" || type == "observation"){
    axios.post('/get_plot_data_simple/', data).then(function(response){
      var data = response.data.plot_data;
      Store.plot.current_hash = response.data.plot_hash;
      // perform necessary processing on data before plotting
      //console.log(JSON.stringify(data));

      var myData = [{key: 'group 1', values: []}];
      for (var i=0; i<data["x"].length; i++){
        var value = data[type][i];

        if(type == "severity") {
          // check whether we should plot this based on the filters
          if(value >= 0) {
            if(!Store.plot.show_successes) continue;
          } else {
            if(!Store.plot.show_violations) continue;
          }
          // negative verdict severity represents violation - colour these bars red
          var color = "#cc0000";
          // other columns in the plot are green since they show non-violating observations
          if (value >= 0) {color = "#00802b"}
        } else {
          color = "blue";
        }
        //value = ( value >= 0 )? value : -Math.abs(Math.log(-value));
        myData[0].values.push({label: new Date(Date.parse(data["x"][i])),
                              value: value,
                              color: color});
      }

      window.open("/display_plot/" + response.data.plot_hash, "plot", "width=1300,height=1000");
    });
  }
  if (type == "between-severity" || type == "between-observation"){
    axios.post('/get_plot_data_between/', data).then(function(response){
      var data = response.data.plot_data;
      Store.plot.current_hash = response.data.plot_hash;

      var myData = [{key: 'group 1', values: []}];
      for (var i=0; i<data["x"].length; i++){
        var value = data[type][i];

        if(type == "between-severity") {
          // check whether we should plot this based on the filters
          if(value >= 0) {
            if(!Store.plot.show_successes) continue;
          } else {
            if(!Store.plot.show_violations) continue;
          }
          // negative verdict severity represents violation - colour these bars red
          var color = "#cc0000";
          // other columns in the plot are green since they show non-violating observations
          if (value >= 0) {color = "#00802b"}
        } else {
          color = "blue";
        }
        myData[0].values.push({label: new Date(Date.parse(data["x"][i])),
                              value: value,
                              color: color});
      }

      window.open("/display_plot/" + response.data.plot_hash, "plot", "width=1300,height=1000");
    })
  }
  if (type == "mixed-severity" || type == "mixed-observation"){
    axios.post('/get_plot_data_mixed/', data).then(function(response){
      var data = response.data.plot_data;
      Store.plot.current_hash = response.data.plot_hash;

      if(type == "mixed-severity") {
        var myData = [{key: 'group 1', values: []}];
        for (var i=0; i<data["x1"].length; i++){
          var value = data[type][i];
          // check whether we should plot this based on the filters
          if(value >= 0) {
            if(!Store.plot.show_successes) continue;
          } else {
            if(!Store.plot.show_violations) continue;
          }
          // negative verdict severity represents violation - colour these bars red
          var color = "#cc0000";
          // other columns in the plot are green since they show non-violating observations
          if (value >= 0) {color = "#00802b"}
          myData[0].values.push({label: new Date(Date.parse(data["x1"][i])),
                                value: value,
                                color: color});
        }
      } else {
        var myData = [{key: 'subatom 0', values: []}, {key: 'subatom 1', values: []}];
        for (var i=0; i<data["x1"].length; i++){
          var value1 = data[type+"-1"][i];
          var value2 = data[type+"-2"][i]

          myData[0].values.push({label: new Date(Date.parse(data["x1"][i])),
                                 value: value1});
          myData[1].values.push({label: new Date(Date.parse(data["x1"][i])),
                                 value: value2});
        }
      }

      window.open("/display_plot/" + response.data.plot_hash, "plot", "width=1300,height=1000");
    })
  }
  if (type == "between-path-severity" || type == "between-path-observation" ||
      type == "simple-path-severity" || type == "simple-path-observation" ||
      type == "mixed-path-severity" || type == "mixed-path-observation") {
    var path_index = Store.chosen_path_index;
    Store.plot.current_hash = path_plot_hash;
    var myData = [{key: "path index: " + path_index, values: []}];

    if(type == "simple-path-severity" || type == "between-path-severity" || type == "mixed-path-severity") {
      for (var i=0; i<path_plot_data[path_index]["x"].length; i++) {
        var value = path_plot_data[path_index]["severities"][i]
        // check whether we should plot this based on the filters
        if(value >= 0) {
          if(!Store.plot.show_successes) continue;
        } else {
          if(!Store.plot.show_violations) continue;
        }
        // negative verdict severity represents violation - colour these bars red
        var color = "#cc0000";
        // other columns in the plot are green since they show non-violating observations
        if (value >= 0) {color = "#00802b"}
        myData[0].values.push({label: new Date(Date.parse(path_plot_data[path_index]["x"][i])),
                              value: value,
                              color: color});
      }

      window.open("/display_path_plot/" + path_plot_hash + "/severity/", "plot", "width=1300,height=1000");

    } else {

      for (var i=0; i<path_plot_data[path_index]["x"].length; i++) {
          myData[0].values.push({label: new Date(Date.parse(path_plot_data[path_index]["x"][i])),
                                 value: path_plot_data[path_index]["observations"][i]});
      }

      window.open("/display_path_plot/" + path_plot_hash + "/observation/", "plot", "width=1300,height=1000");

    }
  }
};

var highlight_paths = function(root_obj) {
  var that = root_obj;
  // get the plot type
  var type = Store.plot.type;
  var data = plot_data;
  var resp, main_lines, parameter_lines;
  if (type == "simple-path"){
    axios.post('/get_path_data_simple/', data).then(function(response){
      resp = response.data.parameter_values;
      path_plot_hash = response.data.path_hash;
      console.log(path_plot_hash)
      path_plot_data = resp;

      main_lines = response.data.main_lines;
      parameter_lines = response.data.parameters;
      console.log("parameter lines received");
      console.log(parameter_lines);

      // the selected option was to highlight the paths by severity
      console.log("computing path data");
      console.log(data);
      var lines_to_colors = [];

      if(resp.length > 0) {

        var all_severities = resp[0]["severities"];
        for (var i=1; i<resp.length; i++) {
          all_severities = all_severities.concat(resp[i]["severities"]);
        }
        var min_sev = Math.min(...all_severities);
        var max_sev = Math.max(...all_severities);

        var negative_range = min_sev<0 ? (0 - min_sev) : 0;
        var positive_range = max_sev>0 ? (max_sev) : 0;

        for (var i=0; i<resp.length; i++) {
          var avg = 0;
          for (var j=0; j<resp[i]["severities"].length; j++){
            avg += resp[i]["severities"][j];
          }
          avg /= resp[i]["severities"].length;
          var avg_index;
          if (avg < 0) {
            avg_index = Math.round((avg - min_sev)/negative_range * 60);
          } else {
            avg_index = Math.round(60 + avg/positive_range * 60);
          }
          var dict = {lines: resp[i]["lines"],
                      color: "hsl("+avg_index+", 78%, 90%)"};
          lines_to_colors.push(dict);
        }
        var data = {
          first_line: first_line,
          last_line: last_line,
          lines_to_colors: lines_to_colors,
          main_lines: main_lines,
          parameter_lines: parameter_lines
        };
      } else {
        var data = {
          first_line: first_line,
          last_line: last_line,
          lines_to_colors: [],
          main_lines: main_lines,
          parameter_lines: []
        };
      }
      that.$root.$emit('path-data-ready', data);
    })
  }
  if (type == "between-path"){
    var sorted = plot_data["selected_line_numbers"][0] <= plot_data["selected_line_numbers"][1];
    var first_line = sorted ? plot_data["selected_line_numbers"][0] : plot_data["selected_line_numbers"][1];
    var last_line = sorted ? plot_data["selected_line_numbers"][1] : plot_data["selected_line_numbers"][0];

    axios.post('/get_path_data_between/', data).then(function(response){
      resp = response.data.parameter_values;
      path_plot_hash = response.data.path_hash;
      console.log(path_plot_hash)
      path_plot_data = resp;

      main_lines = response.data.main_lines;
      parameter_lines = response.data.parameters;
      console.log("parameter lines received");
      console.log(parameter_lines);

      // the selected option was to highlight the paths by severity
      console.log("computing path data");
      console.log(data);
      var lines_to_colors = [];

      if(resp.length > 0) {

        var all_severities = resp[0]["severities"];
        for (var i=1; i<resp.length; i++) {
          all_severities = all_severities.concat(resp[i]["severities"]);
        }
        var min_sev = Math.min(...all_severities);
        var max_sev = Math.max(...all_severities);

        var negative_range = min_sev<0 ? (0 - min_sev) : 0;
        var positive_range = max_sev>0 ? (max_sev) : 0;

        for (var i=0; i<resp.length; i++) {
          var avg = 0;
          for (var j=0; j<resp[i]["severities"].length; j++){
            avg += resp[i]["severities"][j];
          }
          avg /= resp[i]["severities"].length;
          var avg_index;
          if (avg < 0) {
            avg_index = Math.round((avg - min_sev)/negative_range * 60);
          } else {
            avg_index = Math.round(60 + avg/positive_range * 60);
          }
          var dict = {lines: resp[i]["lines"],
                      color: "hsl("+avg_index+", 78%, 90%)"};
          lines_to_colors.push(dict);
        }
        var data = {
          first_line: first_line,
          last_line: last_line,
          lines_to_colors: lines_to_colors,
          main_lines: main_lines,
          parameter_lines: parameter_lines
        };
      } else {
        var data = {
          first_line: first_line,
          last_line: last_line,
          lines_to_colors: [],
          main_lines: main_lines,
          parameter_lines: []
        };
      }
      that.$root.$emit('path-data-ready', data);
    })
  }
  if (type == "mixed-path"){
    var sorted = plot_data["selected_line_numbers"][0] <= plot_data["selected_line_numbers"][1];
    var first_line = sorted ? plot_data["selected_line_numbers"][0] : plot_data["selected_line_numbers"][1];
    var last_line = sorted ? plot_data["selected_line_numbers"][1] : plot_data["selected_line_numbers"][0];

    axios.post('/get_path_data_mixed/', data).then(function(response){
      resp = response.data.parameter_values;
      path_plot_hash = response.data.path_hash;
      console.log(path_plot_hash)
      path_plot_data = resp;

      main_lines = response.data.main_lines;
      parameter_lines = response.data.parameters;
      console.log("parameter lines received");
      console.log(parameter_lines);

      // the selected option was to highlight the paths by severity
      console.log("computing path data");
      console.log(data);
      var lines_to_colors = [];

      if(resp.length > 0) {

        var all_severities = resp[0]["severities"];
        for (var i=1; i<resp.length; i++) {
          all_severities = all_severities.concat(resp[i]["severities"]);
        }
        var min_sev = Math.min(...all_severities);
        var max_sev = Math.max(...all_severities);

        var negative_range = min_sev<0 ? (0 - min_sev) : 0;
        var positive_range = max_sev>0 ? (max_sev) : 0;

        for (var i=0; i<resp.length; i++) {
          var avg = 0;
          for (var j=0; j<resp[i]["severities"].length; j++){
            avg += resp[i]["severities"][j];
          }
          avg /= resp[i]["severities"].length;
          var avg_index;
          if (avg < 0) {
            avg_index = Math.round((avg - min_sev)/negative_range * 60);
          } else {
            avg_index = Math.round(60 + avg/positive_range * 60);
          }
          var dict = {lines: resp[i]["lines"],
                      color: "hsl("+avg_index+", 78%, 90%)"};
          lines_to_colors.push(dict);
        }
        var data = {
          first_line: first_line,
          last_line: last_line,
          lines_to_colors: lines_to_colors,
          main_lines: main_lines,
          parameter_lines: parameter_lines
        };
      } else {
        var data = {
          first_line: first_line,
          last_line: last_line,
          lines_to_colors: [],
          main_lines: main_lines,
          parameter_lines: []
        };
      }
      that.$root.$emit('path-data-ready', data);
    })
  }
}

Vue.use(VuejQueryMask);

Vue.component("alert", {
  template : `
  <!--<div class="alert alert-info alert-dismissible" role="alert" v-if="is_open">
    <button type="button" class="close" data-dismiss="alert" aria-label="Close" @click="close()">
      <span aria-hidden="true">&times;</span>
    </button>
    {{ message }}
  </div>-->
  `,
  props : ["message"],
  data : function() {
    return {
      is_open : true
    }
  },
  methods : {
    close : function() {
      this.is_open = false;
    }
  }
});


Vue.component("loading-spinner", {
  template : `
  <div class="loading-spinner" role="status" v-if="in_progress"></div>
  `,
  data : function() {
    return {
      store : Store
    }
  },
  computed : {
    in_progress : function() {
      return this.store.status.loading;
    }
  }
});


Vue.component("selection-tabs", {
  props : ["tree"],
  template : `
    <div class="selection-phases">
      <div class="phase" v-bind:class="{show : show_test_data}">
        <test-data></test-data>
      </div>
      <div class="phase" v-bind:class="{show : show_spec}">
        <machine-function-property :tree="tree"></machine-function-property>
      </div>
      <div class="phase" v-bind:class="{show : show_calls}">
        <function-calls></function-calls>
      </div>
    </div>
  `,
  data : function() {
    return {
      store : Store
    }
  },
  computed : {
    show_test_data : function() {
      return this.store.current_tab == "test-data";
    },
    show_spec : function() {
      return this.store.current_tab == "machine-function-property";
    },
    show_calls : function() {
      return this.store.current_tab == "function-calls";
    }
  },
  mounted : function() {
    $(window).scroll(function() {
        clearTimeout(sidebar_scroll_timeout);
        sidebar_scroll_timeout = setTimeout(function() {
            $(".selection-phases").animate({"margin-top": $(window).scrollTop()});
        }, 100);
    });
  }
});


Vue.component("test-data", {
  template : `
  <div v-if="tests_exist" class="panel panel-success">
    <div class="panel-heading">
      <h3 class="panel-title" id="test-cases-title" @click="showTests=!showTests">Test Cases</h3>
    </div>
    <div class="panel-body">
      <transition name="slide-fade">
      <div v-show="showTests" class="list-group" id="test-cases-list">
        <alert message="Select a test to browse performance data related to it." />
        <div class="list-group-item">
          <input type="text" v-model="filter_string" placeholder="Filter tests..." class="form-control" />
        </div>
        <form>
        <div v-for="(b, index) in filtered_buttons" :key="index" class="list-group-item">
          <input type='radio' :test-id="b.testname" :value="b.testname" v-model="checked_test"
            @click="select_test($event)"/>
          {{b.testname}}
        </div>
        </form>
      </div>
      </transition>
    </div>
  </div>`,
  data() {
    return {
      showTests : true,
      chosen: '',
      all_names:[],
      filter_string: "",
      all_buttons : [],
      checked_test : null,
      store : Store
    }
  },
  computed : {
    tests_exist : function() {
      return this.store.tests_exist;
    },
    filtered_buttons : function() {
      // use the value of this.filter_string to decide which buttons we should display
      if(this.filter_string != "") {
        var final_list = [];
        for(var i=0; i<this.all_buttons.length; i++) {
          if(this.all_buttons[i].testname.includes(this.filter_string)) {
            final_list.push(this.all_buttons[i]);
          }
        }
        return final_list;
      } else {
        return this.all_buttons;
      }
    }
  },
  methods: {
    select_test : function(e) {
      // get the functions called during executions of the selected test
      // and emit an event that tells the specification-listing component to reload
      var that = this;
      // get the test name from the DOM since reactivity hasn't caught up yet
      test_name = $(e.target).attr("value");
      axios.post("/list_functions_by_tests/", {"names" : [test_name]}).then(function(response) {
        tree = response.data;
        that.$root.$emit('tests-selected', tree);
      });
      Store.selected_tests = [test_name];
      that.store.current_tab = "machine-function-property";
    },
    select_all_tests: function(){
      var is_checked = $("#select-all-tests").prop("checked");
      $("#test-cases-list input:checkbox").prop("checked", is_checked);
      if (is_checked) {
        for(var i=0; i<this.filtered_buttons.length; i++){
          this.checkedTests.push(this.filtered_buttons[i].testname);
        }
      }
      else {
        this.checkedTests = [];
      }
    }
  },
  created(){
    var that = this;
    // get all tests, without a filter
    // for now we'll perform filtering on the client side
    axios.get("/list_tests/").then(function(response){
      //console.log(response.data)
      var test_list = response.data;
      var n = test_list.length;
      var buttons = [];
      var names = [];
      for (var i=0; i<n; i++){
        var dict = {testname: test_list[i][0]}
        buttons.push(dict);
        names.push(dict["testname"]);
      }
      that.store.tests_exist = ( n > 0 );
      if (n>0) {
        that.store.current_tab = "test-data";
        that.$root.$emit("tests-detected");
      } else {
        that.store.current_tab = "machine-function-property";
      }
      that.all_buttons = buttons;
      that.all_names = names;
    })
  },
  watch: {
    chosen: function(value) {
      if (value==''){
        this.filterTests("");
      }
    }
  },
  mounted(){
    var that = this;
    //this.$root.$on("function-select", function(id){that.showTests = false;})
  }
})


Vue.component("machine-function-property", {
  props: ['tree'],
  template : `
    <div class="panel panel-success machine-function-property">
      <div class="panel-heading">
        <h3 class="panel-title" id="function-title">
            Machine / Function / Query
        </h3>
      </div>
      <div class="panel-body">
        <alert message="Select a query to see relevant calls." />
        <transition name="slide-fade">
        <div class="list-group" id="function-list">
          <p v-if="store.tests_exist"/>
          <p v-if="store.tests_exist">
            <a href="#" @click="previous($event)" style="padding-left: 15px;" class="btn btn-primary">&lt; Back</a>
          </p>
          <div id="function-list-data"></div>
          <div class="tab">
            <button v-for="(value,key) in tree" :class="(key===showTab)? 'tablinks active':'tablinks' "
                @click="selectTab(key)" v-show="key">
                {{key}}
            </button>
          </div>
          <subtree v-for="(value,key) in tree" v-show="(key === showTab)"
            :key="key" :id="key" :content="value">
          </subtree>
        </div>
        </transition>
      </div>
    </div>`,
  data() {
    return {showTab: "", store: Store}
  },
  methods : {
    selectTab: function(selectedTab){
      // selectedTab contains the ID of the tabcontent element which needs to be displayed
      this.showTab = selectedTab;
    },
    previous : function(e) {
      e.preventDefault();
      Store.current_tab = 'test-data';
    }
  },
  mounted() {
    console.log("tree on lhs:");
    console.log(this.tree);
    // all tabs except for the one whose ID is == showTab are hidden
    // store the ID of the first tab so that it gets displayed
    var machine_keys=[];
    for (key in this.tree){
      machine_keys.push(key)
    }
    this.selectTab(machine_keys[0]);
    var that = this;
    this.$root.$on('function-select', function(dict){
      // after selecting a function (specification), hide functions list to make space for calls
      //that.showFunctions = false;
    })
    this.$root.$on('tests-detected', function(){
      //that.showFunctions = false;
    })
    this.$root.$on('tests-selected', function(tree){
      that.tree = tree;
      //that.showFunctions = true;
    })
  }

})


Vue.component("subtree",{
  props: ['id', 'content'],
  template:  `
    <div class="tabcontent" :id=this.tabid>
      <subtreelevel :htmlcontent="content" :path="id"> </subtreelevel>
    </div>`,
  data() {
    return { tabid: "tab-" + this.id }
  }
})


Vue.component("subtreelevel", {
  /*recursive component, properties store the following information:
  htmlcontent - function tree based on which the html of the element is built, updated for each level
  path - the path through the function tree to the current element
  panelid, stylepadding - strings which are used to define the header on each level
  keyname - title in the header, taken as a dictionary key on the current tree level

  after adding the header for the current level, iterate through the lower level to repeat the process
  if the subtreelist is empty, this is an indicator that we reached the last level
  - this means it is time to display the specification - the recursion stops here*/
  props: ['htmlcontent', 'path', 'panelid', 'stylepadding', 'keyname'],
  template: `
    <div class="panel panel-default" style="inherit">
      <div v-if="keyname" class="panel-heading">
        <h3 class="panel-title" :id="this.panelid" :style="this.stylepadding" @click=toggleView()>
          {{this.keyname}} </h3>
      </div>
      <div :class="this.show ? 'panel-body show' : 'panel-body'">
        <div class="list-group" :id="path">
          <subtreelevel v-for="(level,index) in this.subtreeslist" :key="index" :htmlcontent="level.nextcontent"
          :path="level.nextpath" :panelid="level.panelid" :stylepadding="level.stylepadding"
          :keyname="level.keyname"></subtreelevel>
          <div v-if="!this.subtreelist">
            <button v-for="(b, index) in this.buttons" type="button" class="list-group-item"
              :function-id="b.functionid" :style="b.padding"
                @click="selectFunction(b.functionid, b.property_hash, b.str)">
              <specification :spec=b.str :change="0"></specification>
            </button>
          </div>
        </div>
      </div>
    </div>
    `,
  data() {
    // take subtree and path from properties parsed to this component
    var subtree = JSON.parse(JSON.stringify(this.htmlcontent));
    var path = this.path;
    var padding = String(path.split("-").length * 20) + "px";

    // check if the last level is reached - if it is, return an empty subtrees list to indicate this
    // also return the HTML needed to build the element with the specification
    if(Array.isArray(subtree)) {
      var buttons = [];
      for(var i=0; i<subtree.length; i++) {
        var str = subtree[i][2];
        //str = decodeHTML(str);
        buttons.push({
          functionid: subtree[i][0],
          padding : "padding-left:" + padding,
          str : str,
          property_hash : subtree[i][1]
        });
      }
      return {
        buttons: buttons,
        subtreeslist:[],
        store : Store,
        show : true
      }

    // if this is not the last level, iterate through the keys in the subtree and return the list
    // based on which new subtree components will be defined
    } else {
      var keys = [];
      for (var key in subtree) {
        keys.push(key);
      }
      //console.log("path="+path+"; keys="+ keys);

      var dicts_list = [];
      for(var i=0; i<keys.length; i++) {
        var key = keys[i];
        // create list inside the current list in the dom
        var new_path = (path != "") ? (path + "-" + key) : key;
        var panel_id = "external-" + new_path;
        var style_padding = "padding-left: " + padding;

        dicts_list.push({keyname: key,
          nextcontent : subtree[key], nextpath : new_path,
          stylepadding : style_padding, panelid : panel_id});
      }
      return {subtreeslist : dicts_list, show : true}
    }
  },
  methods : {
    selectFunction: function(id, property_hash, code){

      start_loading();

      // switch to the tab showing the list of calls
      this.store.current_tab = 'function-calls';

      path_highlight_mode_on = false;

      this.store.selected_property_hash = property_hash;
      this.store.selected_function_id = id;
      this.$root.$emit(
        'function-select',
        {
          selected_function_id: id,
          specification_code: code,
          property_hash: property_hash
        }
      );
    },
    toggleView: function(){
      this.show = !this.show;
    }
  }
})


Vue.component("function-calls", {
  template : `
    <div class="panel panel-success function-calls">
      <div class="panel-heading">
        <h3 class="panel-title" id="function-call-title">Function Calls</h3>
      </div>
      <div class="panel-body">
        <div class="list-group" id="function-call-list">
          <div v-if="message" class="please-select"><p>{{message}}</p></div>
          <alert v-if="!message" message="Select one or more calls to load performance data." />
          <div v-if="!message" class="list-group-item">
            <p><a href="#" @click="previous($event)" class="btn btn-primary">&lt; Back</a></p>
            <form class="form-inline" action="">
            <b>From</b> <vue-mask id="filter-from" v-model="filter_from" mask="00/00/0000 00:00:00"
                         placeholder="DD/MM/YYYY hh:mm:ss" :raw="false" class="form-control"> </vue-mask> <br>
            <b>To &nbsp;&nbsp;&nbsp; </b> <vue-mask id="filter-to" v-model="filter_to" mask="00/00/0000 00:00:00"
                       placeholder="DD/MM/YYYY hh:mm:ss" :raw="false" class="form-control"> </vue-mask>
            <button @click="select_filtered($event)" class="btn btn-default"> Filter calls </button>
            </form>
          </div>
          <button v-if="!message" class="list-group-item">
            <input type='checkbox' id="select-all-calls" @click="select_all_calls()"/><b> Select all </b>
          </button>
          <button v-for="(b, index) in this.buttons" :key="index" class="list-group-item">
            <input type='checkbox' :function-call-id="b.callid" :value="b.callid" v-model="checkedCalls"/>
            {{b.callstart}}
            <span v-if="tests_exist" class="badge" v-bind:class="b.testresult">unit test</span>
            <span class="badge" v-bind:class="translate_verdict(b.verdict)">query</span>
            <span class="badge">lasted {{b.callduration}} seconds</span>
          </button>
        </div>
      </div>
    </div>`,
  data() {
    return {
      message : "Select a function first.",
      buttons : [],
      checkedCalls: [],
      filter_from: "",
      filter_to: "",
      func_id: 0,
      store : Store}
  },
  computed : {
    tests_exist : function() {
      return this.store.tests_exist;
    }
  },
  methods: {
    previous : function(e) {
      e.preventDefault();
      this.store.current_tab = 'machine-function-property';
    },
    translate_verdict : function(v) {
      if(v == 1) return "Success";
      else return "Violation";
    },
    select_all_calls: function(){
      start_loading();
      var is_checked = $("#select-all-calls").prop("checked");
      $("#function-call-list input:checkbox").prop("checked", is_checked);
      if (is_checked) {
        for(var i=0; i<this.buttons.length; i++){
          this.checkedCalls.push(this.buttons[i].callid);
        }
      }
      else {
        this.checkedCalls = [];
      }
      // display only relevant alerts
      Store.binding_selected = false;
      Store.subatom_selected = false;

      stop_loading();

    },
    select_filtered: function(e){
      e.preventDefault();
      start_loading();

      $("#function-call-list input:checkbox").prop("checked", false);
      this.checkedCalls = [];
      var time = {function: this.func_id, from: this.filter_from, to: this.filter_to,
                  tests: Store.selected_tests};
      var that = this;

      axios.post("/list_calls_between/", time).then(function(response){
        var ids_list = response.data;
        var calls_list = $("#function-call-list input:checkbox");
        for (var i=0; i<that.buttons.length; i++){
          if (that.buttons[i].callid == ids_list[0]){
            for (var j=i; j<i+ids_list.length; j++){
              that.checkedCalls.push(that.buttons[j].callid);
              $(calls_list[j+1]).prop("checked", true);
            }
            break
          }
        }
      })
      stop_loading();
    }
  },
  mounted(){
    var obj = this;
    this.$root.$on('tests-selected', function(tree){
      obj.message = "Select a function first.";
      obj.buttons = [];
      obj.checkedCalls = [];
      obj.filter_from = "";
      obj.filter_to = "";
      obj.func_id = 0;
      obj.store = Store;
    })
    this.$root.$on('function-select', function(dict){
      // when a specification is selected, get the calls list from server
      // while it's loading, display a temporary message
      // since each call has an input checkbox, we need to catch any changes in the selection

      obj.message = "Loading function calls.  This can take some time if there are many.";
      obj.buttons = [];
      obj.checkedCalls = [];
      obj.func_id = dict["selected_function_id"];

      axios.post(
        '/list_function_calls/',
        {
          function: obj.func_id,
          tests: Store.selected_tests
        }
      ).then(function(response){
        var data = response.data["data"];
        obj.message = "";
        var buttons_list = [];
        var i;
        for(i=0; i<data.length; i++) {
          var button = {
            callid : data[i][0],
            callstart: data[i][2],
            callduration: data[i][6],
            verdict: data[i][7],
            testresult: obj.store.tests_exist ? data[i][8] : null
          }
          buttons_list.push(button)
        }
        obj.buttons = buttons_list;
        obj.filter_from = buttons_list[0].callstart;
        obj.filter_to = buttons_list[i-1].callstart;

        obj.$root.$emit('calls-loaded', dict);
      })
    })
  },
  watch: {
    checkedCalls: function(value){
      var function_call_ids = [];
      var that = this;
      for (var i=0; i<value.length; i++){
        function_call_ids.push(""+value[i]);
      }

      Store.selected_calls = function_call_ids;
      if (!plot_visible) {
        // display code interface
        if (function_call_ids.length){
          axios.post(
            "/get_function_calls_data/",
            {
              "ids" : function_call_ids,
              "property_hash" : Store.selected_property_hash
            }
          ).then(function(response) {
            tree = response.data;
            that.$root.$emit('calls-selected',tree);
          });
        }
      } else {
        // add data to plot without displaying code interface
        plot_data.calls = function_call_ids;
        // trigger plotting - since plots are opened in a separate window, we don't
        // do this for now
        //generate_plot(this);
      }
    }
  }
})


Vue.component("code-view", {
  /* This is the most complex component. It is empty at the beginning, but upon the selection
  of the function and the calls, some data is displayed. When the user selects a function,
  the specification and the source code of the selected function are shown. Additionally,
  the lines in the code that quantifiers in the specification refer to are highlighted.
  When the calls are also selected, more data is displayed and some code lines are hidden.*/
  template : `
    <div class="panel panel-success code-view">
      <div class="panel-heading">
        <h3 class="panel-title">Code View</h3>
      </div>
      <div class="panel-body" id="verdict-list">
        <div v-if="message" class="please-select">{{message}}</div>
        <alert v-if="binding_is_selected"
            message="Select a part of the query to narrow down critical statements in the code." />
        <div v-if="specification_code" id='specification_listing'>
          <specification :spec="this.specification_code" :change="1" />
        </div>
        <plot></plot>
        <!--<path-code :code="code_lines" :start="start_line"></path-code>-->
        <div v-if="code_lines" class='code_listing' id="code-listing">
          <div v-if="code_error" class="alert alert-danger" role="alert">
            <strong>Error: </strong>{{code_error}}
          </div>
          <div v-if="no_paths" class="alert alert-info" role="alert">
            {{no_paths}}
          </div>
          <alert v-if="calls_are_selected" message="Select a binding in the code listing below." />
          <alert v-if="subatom_is_selected" message="Hover over a critical statement to see analysis options." />
          <div v-for="(line,index) in code_lines" :key="index" :class="line.class"
          :id="line.id" :style="line.background" :save-background-color="line.color"
          v-show="show_line(line.show)">
            <span class="line-number"> {{line.line_number}} </span>
            <span class="language-python" v-html="line.content"> </span>
            <span v-if="line.addmenu"><a href="#" class="badge options" @click="toggle_menu($event)">options</a></span>
            <span class="span-binding" :id="line.spanid">
            <button v-for="b in line.buttons"
            class="binding-button" :binding-button="b.binding" :style="b.font"
            @click="selectBinding(b.binding, b.subtree, b.lines)">binding {{b.binding}}</button>
            </span>
            <p v-show="show_empty_line_marker(line.showempty)" class="empty-line" :id="line.emptyid"><b> ... </b><br> </p>
            <dropdown v-if="line.addmenu" :tree="this.tree" :dict="line.dict" :binding="this.binding"
            :line=line.line_number @firstselected="selectOther($event)"> </dropdown>
          </div>
        </div>
      </div>
    </div>`,
  data(){
    return {
      message: "Select a function and then one or more calls, first.",
      code_error: false,
      no_paths: false,
      specification_code: "",
      code_lines: [],
      start_line: 0,
      tree: {},
      binding: undefined,
      store : Store}
  },
  computed : {
    calls_are_selected : function() {
      return this.store.selected_calls.length > 0;
    },
    binding_is_selected : function() {
      return this.store.binding_selected;
    },
    subatom_is_selected : function() {
      return this.store.subatom_selected;
    }
  },
  methods : {
    show_line : function(line_show_flag) {
      return line_show_flag || path_highlight_mode_on;
    },
    show_empty_line_marker : function(line_show_flag) {
      return !path_highlight_mode_on && line_show_flag;
    },
    toggle_menu : function(e) {
      e.preventDefault();
      $(e.target).parent().parent().find(".dropdown-content").slideToggle();
      $(e.target).toggleClass("active");
    },
    selectBinding : function(binding, tree, lines){
      // binding stores the index of the binding, tree is the branch tree[binding]
      // lines is a list of line numbers that need to be highlighted

      var whole_code = this.code_lines;
      var start_line = this.start_line;

      // reset the background colors of previously highlighted lines
      Store.first_point_selected = false;
      this.no_paths = false;
      for (var i=0; i<whole_code.length; i++){
        var line = whole_code[i];
        line.addmenu = false;
        line.class = "code_listing_line";
        if (line.color){
          line.background = "background-color: #ebf2ee";
        }
        else {
          whole_code[i].background = "background-color: transparent";
        }
        for (var j=0; j<line.buttons.length; j++){
          if (line.buttons[j].binding == binding){
            line.buttons[j].font = "font-weight: bold";
          }
          else{
            line.buttons[j].font = "font-weight: normal";
          }
        }
      }

      for (var i=0; i<lines.length; i++){
        var line = whole_code[lines[i]-start_line];
        line.background = "background-color: " + line.color;
      }
      this.binding = binding;
      selected_binding = binding;
      this.tree = tree;
      this.store.path_view = false;
      this.$root.$emit("binding-selected", tree);
    },
    selectOther : function(list){
      for (var i=0; i<this.code_lines.length; i++){
        this.code_lines[i].addmenu = false;
      }

      for (var i=0; i<list.length; i++){
        var index = list[i]["line"]-this.start_line;
        var line = this.code_lines[index];

        line.background = "background-color: " + line.color;
        line.addmenu = true;
        line.class = "code_listing_line code_listing_line-clickable";
      }
    }
  },
  mounted(){
    var obj2 = this;
    $("#code-listing").height(
      $(".panel.panel-success.function-calls").outerHeight() -
      $(".panel.panel-success.code-view").find(".panel-heading").first().outerHeight() -
      $("#specification_listing").outerHeight());
    this.$root.$on('tests-selected', function(tree){
      obj2.message = "Select a function and then one or more calls, first.";
      obj2.specification_code = "";
      obj2.code_lines = [];
      obj2.start_line = 0;
      obj2.tree = {};
      obj2.binding = undefined;
      obj2.store = Store;
      obj2.no_paths = false;
    })
    this.$root.$on('calls-loaded', function(dict){
      path_highlight_mode_on = false;
      start_loading();

      obj2.message = "";
      obj2.specification_code = dict["specification_code"];
      obj2.no_paths = false;
      axios.get('/get_source_code/'+dict["selected_function_id"]).then(function(response){
        var code_data = response.data;
        if (code_data["error"]){
          obj2.code_error = code_data["error"];
          stop_loading()
        }
        var code_lines = code_data["code"];
        var current_line = code_data["start_line"];
        obj2.start_line = current_line;

        // we also want to display binding reference at the end of each line
        // first, go through bindings and collect all line numbers they refer to
        var bindings_list = code_data["bindings"];
        var line_numbers = [];
        for (var i=0; i<bindings_list.length; i++){
          binding = bindings_list[i];
          line_numbers = line_numbers.concat(binding["binding_statement_lines"]);
        }

        // add each line as a div element, if it is in the list of binding statement lines,
        // also add a span element to the content of the line - later, we will add binding labels to it
        var lines_list = [];
        for(var i=0; i < code_lines.length; i++) {
          code_lines[i] = hljs.highlight("python", code_lines[i]).value;
          var line_text = code_lines[i].replace(/\t/g, "&nbsp;&nbsp;&nbsp;").replace(/^[ \t]+/mg, html_space_replace);
          var line_div = {line_number: current_line, id: "line-number-" + current_line,
                          background: "background-color: transparent", color: "", show: true,
                          added_empty_line: false, spanid: "span-bindings-line-" + current_line,
                          content: line_text, buttons: [], emptyid: "empty-line-" + current_line,
                          showempty: false, addmenu: false, class: "code_listing_line", dict: {}}


          lines_list.push(line_div);
          current_line++;
        }

        obj2.code_lines = lines_list;


        // we want to highlight the quantification in the specification code
        // with the same color as the line of code it refers to
        var quantification_ids = obj2.specification_code["vars"].split(", ");

        // for each binding line go through the specification to find the quantification
        // that refers to that line and highlight it the same color as the line in the code
        for (var i=0; i<bindings_list.length; i++){
          var binding = bindings_list[i];
          var line_numbers = binding["binding_statement_lines"];

          for (var j=0; j<line_numbers.length; j++){
            var no = line_numbers[j]
            var color = code_highlight_palette[j];
            lines_list[no-code_data["start_line"]].background = "background-color: "+color;
            lines_list[no-code_data["start_line"]].color = color;
            //$("#span-bindings-line-"+no).append(" "+binding["id"]);
          } //end j-loop
        } //end i-loop

        stop_loading();
      })
    })
    this.$root.$on('calls-selected', function(tree){
      obj2.tree = tree;
      path_highlight_mode_on = false;

      var show_lines = []; //stores all lines that are of interest plus a few around them - we will hide the rest
      var start_line = obj2.start_line;
      var whole_code = obj2.code_lines;

      //clean up the binding buttons and dropdown menus from previous selection
      for (var i=0; i<whole_code.length; i++){
        whole_code[i].buttons = [];
        whole_code[i].addmenu = false;
        whole_code[i].class = "code_listing_line";
        whole_code[i].background = "background-color: transparent";
      }
      obj2.store.path_view = false;
      obj2.no_paths = false;


      // iterate through the bindings to highlight the lines and separate those paired with
      // a quantifier from those that are of interest because a subatom generates observations there
      for (binding in tree){
        var line_numbers = []; //stores all points of interest
        var lines_points = []; //stores only those stored by bindings
        for (atom in tree[binding]){
          for (subatom in tree[binding][atom]){
            list = tree[binding][atom][subatom];
            for (var i=0; i<list.length; i++){
              if (line_numbers.indexOf(list[i]["code_line"])==-1){
                line_numbers.push(list[i]["code_line"]);
              }
              if (atom=="-1" && lines_points.indexOf(list[i]["code_line"])==-1){
                lines_points.push(list[i]["code_line"]);
              }

            }
          }
        }
        show_lines = show_lines.concat(line_numbers);
        for (var i=0; i<line_numbers.length; i++){
          var no = line_numbers[i] - obj2.start_line;
          whole_code[no].background = "background-color: #ebf2ee"
          color = whole_code[no].color;
          if (!(color)){
            whole_code[no].color = "#def1fc";
          }
        }
        for (var i=0; i<lines_points.length; i++){
          var no = lines_points[i];
          whole_code[no-start_line].buttons.push({binding: binding, subtree: tree[binding],
            lines: line_numbers, font: "font-weight: normal"});
          }
        }

      show_lines = show_lines.sort();

      //in addition to the lines stored in leaves, we want to display the first line
      // and in this case, three lines around each instrumentation point
      var more_lines = [obj2.start_line];
      for (var i=0; i<show_lines.length; i++){
        var current_line_number = show_lines[i];
        for (var j=1; j<3; j++){
          more_lines.push(current_line_number+j);
          more_lines.push(current_line_number-j);
        }
      }
      show_lines = show_lines.concat(more_lines);

      for (var i=0; i<whole_code.length; i++){
        var line_id = whole_code[i].id.split("-");
        var id_line_number = line_id[line_id.length-1];
        if (show_lines.indexOf(parseInt(id_line_number))==-1){
          whole_code[i].show = false;
        }
        else{
          whole_code[i].show = true;
        }
      }

      // insert a spacing where there is a jump in line numbers
      show_lines = show_lines.sort(function(a, b){return a - b});

      for (var i=0; i<show_lines.length; i++){
        if (show_lines[i] < (show_lines[i+1] - 1)){
          whole_code[show_lines[i]-obj2.start_line].showempty = true;
        }
        else{
          whole_code[show_lines[i]-obj2.start_line].showempty = false;
        }
      }
    })
    this.$root.$on("subatom-selected", function(dict){
      /* For selected calls, binding, and subatom, highlight the lines that represent
      instrumentation points monitored during those calls and at which observation were
      generated by the selected subatom. In addition to highlighing those lines, we also want
      to be able to select them as instrumentation point and fetch some data about the
      corresponding observations and verdicts in order to visualise the performance analysis results.
      The visualisation options are given within a dropdown menu.
      */
      var atom_index = dict["atom"];
      var sub_index = dict["subatom"];
      var inst_points_list = obj2.tree[atom_index][sub_index];
      var whole_code = obj2.code_lines;

      var lines_list = [];
      for (var i=0; i<inst_points_list.length; i++){
        var no = inst_points_list[i]["code_line"];
        //$("#line-number-"+no).attr('save-background-color',color);
        lines_list.push(no);
      }

      // clean up any previous dropdowns and reset highlights back to a light colour
      // reset the class of the line back to non-clickable
      obj2.store.path_view = false;
      obj2.no_paths = false;
      for (var i=0; i<whole_code.length; i++){
        if (whole_code[i].color) {
          whole_code[i].background = "background-color: #ebf2ee";
          whole_code[i].addmenu = false;
          whole_code[i].class = "code_listing_line";
        }
        else {
          whole_code[i].addmenu = false;
          whole_code[i].background = "background-color: transparent";
        }
      }

      // now highlight and add dropdowns to the lines in lines_list
      for (var i=0; i<lines_list.length; i++){
        var line = whole_code[lines_list[i]-obj2.start_line]
        line.background = "background-color: " + line.color;
        line.dict = dict;
        line.addmenu = true;
        line.class = "code_listing_line code_listing_line-clickable";
      }
    })
    this.$root.$on('path-data-ready', function(data_ready){
      var whole_code = obj2.code_lines;
      console.log(data_ready);
      var start = obj2.start_line;

      if (data_ready["lines_to_colors"].length == 0) {
        obj2.no_paths = "All the runs took the same path - analysis by path unavailable."
      }

      for (var i=0; i<data_ready["lines_to_colors"].length; i++) {
        var dict = data_ready["lines_to_colors"][i];
        for (var j=0; j<dict["lines"].length; j++) {
          console.log(dict["color"])
          whole_code[dict["lines"][j]-start].background = "background-color: " + dict["color"];
        }
      }

      for (var i=0; i<data_ready["main_lines"].length; i++) {
        whole_code[data_ready["main_lines"][i]-start].background = "background-color: #cce0ff";
      }


      obj2.store.path_view = true;

      console.log("highlighting parameters");
      console.log(data_ready["parameter_lines"]);

      for (var i=0; i<data_ready["parameter_lines"].length; i++) {
        whole_code[data_ready["parameter_lines"][i]-start].background = "background-color: lightgrey";
        whole_code[data_ready["parameter_lines"][i]-start].dict = "PATH";
        whole_code[data_ready["parameter_lines"][i]-start].addmenu = true;

      }

      obj2.code_lines = whole_code;
      //$("#path-wrapper").addClass("show");

    })
  }
})


Vue.component("specification", {
  /* this component is still jquery reliant as a part of its HTML (atom and subatom span elements)
  is received from the server side instead of being generated within the template*/
  props: ['spec', 'change'],
  template: `
    <div>
      <p v-for="(v, index) in this.bindvars"><span class="list-group-item-text code" :id="v.id" v-html="v.forall"
          :style="v.background"> </span></p>
      <div class="inner-part">
        <p><span class="list-group-item-text code">Check( </span></p>
        <p><span class="list-group-item-text code" v-html="this.vars"></span></p>
        <p><span class="list-group-item-text code" v-html="this.str"></span></p>
        <p><span class="list-group-item-text code">&nbsp;&nbsp;) </span></p>
        <p><span class="list-group-item-text code">)</span></p>
      </div>
    </div>`,
  data(){
    var spec_dict = this.spec;
    var list = spec_dict["foralls"];
    var bindvars = [];
    for (i=0; i<list.length; i++){
      var bg;
      if (this.change==1){
        bg = "background-color: " +
          code_highlight_palette[spec_dict["vars"].split(", ").indexOf(list[i]["var_id"])] + ";";
      }
      else{
        bg = "background-color: transparent;";
      }
      bindvars.push({id: list[i]["var_id"],
                     forall: "Forall("+list[i]["var_forall"]+").\\ ",
                     background: bg})
    }
    return {
      vars : "&nbsp;&nbsp;lambda " + spec_dict["vars"] + " : (",
      str : "&nbsp;&nbsp;&nbsp;&nbsp; " + spec_dict["atom_str"],
      bindvars: bindvars
    }
  },
  watch: {
    // when a new specification is selected, the specification listing in the code view component
    // must also change - watch for this change and change the data to trigger the rerendering
    spec(newValue) {
      var spec_dict = newValue;
      var list = spec_dict["foralls"];
      var bindvars = [];
      for (i=0; i<list.length; i++){
        var bg;
        if (this.change==1){ bg = "background-color: " +
            code_highlight_palette[spec_dict["vars"].split(", ").indexOf(list[i]["var_id"])] + ";";}
        else { bg = "background-color: transparent;";}
        bindvars.push({id: list[i]["var_id"],
                       forall: "Forall("+list[i]["var_forall"]+").\\ ",
                       background: bg})
      }
      this.vars = "&nbsp;&nbsp;lambda  : ( " + spec_dict["vars"];
      this.str = "&nbsp;&nbsp;&nbsp;&nbsp; " + spec_dict["atom_str"];
      this.bindvars = bindvars;
    }
  },
  mounted(){
    var that = this;
    this.$root.$on('calls-loaded', function(tree){
      // clean up subatom links from previous function selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");
    })

    this.$root.$on('calls-selected', function(tree){
      // clean up subatom links from previous binding selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");
    })

    this.$root.$on('binding-selected', function(tree){
      Store.binding_selected = true;
      path_highlight_mode_on = false;
      // clean up subatom links from previous binding selection
      remove_subatoms = $(".subatom-clickable");
      if (typeof(remove_subatoms) != 'string'){
      for (var i=0; i<remove_subatoms.length; i++){
        $(remove_subatoms[i]).attr("onclick", "");
        $(remove_subatoms[i]).attr('class', "subatom");
      }}
      $($(".subatom-clickable-active")[0]).attr("onclick","");
      $($(".subatom-clickable-active")[0]).attr("class", "subatom");

      // highlight the atoms that generated observations for the selected calls and binding
      // make subatoms clickable - global function subatom_click() will then emit event
      // so that other components can react to the subatom selection
      for (atom in tree){
        var subtree = tree[atom];
        var subs = $($("#specification_listing").find('span.atom[atom-index="' + atom + '"]')[0]).find("span.subatom");
        for (var i=0; i<subs.length; i++){
          $(subs[i]).attr('class', "subatom-clickable");
          $(subs[i]).attr('subtree', JSON.stringify(subtree));
          var dict = {atom: atom, subatom: $(subs[i]).attr("subatom-index")};
          $(subs[i]).attr('onclick', 'subatom_click('+JSON.stringify(dict)+')');
        }
      }
    })

    this.$root.$on("subatom-selected", function(dict){
      path_highlight_mode_on = false;
      // when a subatom is selected, change its class to active - this affects its style
      $($(".subatom-clickable-active")[0]).attr("class", "subatom-clickable");
      var subatom = $(
        $("#specification_listing").find('span.atom[atom-index="' + dict["atom"] + '"]'
      )[0]).find(
        'span[subatom-index="'+dict["subatom"]+'"]'
      )[0];
      $(subatom).attr("class", "subatom-clickable-active");
      // update global state
      Store.plot.constraint_html = decodeHTML($($(".subatom-clickable-active")[0]).parent().html());
      Store.subatom_selected = true;
    })
  }
})


Vue.component("dropdown", {
  // is displayed when hovering above the corresponding line in the code
  // requires data about all the previously selected levels in order to get the filtered verdict
  // and observation values from the server
  props: ["tree", "dict", "binding", "line"],
  template: `
    <div class="dropdown-content">
      <p v-for="option in this.options" class="dropdown-menu-option" @click="selectOption(option.data)">
        {{option.text}} </p>
    </div>
  `,
  data(){
    // menu generated by branching statement should give options for plotting wrt paths taken
    // this case can be recognised as dict will be "PATH"
    if (this.dict == "PATH") {
      var atom_type = Store.plot.type.split("-")[0];
      return {options: [{text: "Plot observations with regards to paths taken",
                         data: {action: atom_type + "-path-plot",
                                type: atom_type + "-path-observation"}
                       },
                        {text: "Plot verdict severity with regards to paths taken",
                         data: {action: atom_type + "-path-plot",
                                type: atom_type + "-path-severity"}}
                       ]
             }
    }


    // indicator variable tells if  the menu is a child of a line selected as
    // the second one in a pair (timeBetween/mixed atom)

    if (Store.first_point_selected){
      var new_list = [];
      var between_or_mixed = Store.plot.type;
      for (var i=0; i<plot_data["other_lines"].length; i++){
        if (plot_data["other_lines"][i]["line"] == this.line){
          new_list.push(plot_data["other_lines"][i]["id"]);
        }
      }
      return {options: [{text: "Select this statement and plot observations",
                         data: {action: between_or_mixed + "-observation-plot",
                                type : between_or_mixed + "-observation",
                                new_points: new_list}},
                        {text: "Select this statement and plot severity",
                         data: {action: between_or_mixed + "-severity-plot",
                                type : between_or_mixed + "-severity",
                                new_points: new_list}},
                        {text: "Select this statement and highlight paths by severity",
                         data: {action: between_or_mixed + "-path",
                                type : between_or_mixed + "-path",
                                new_points: new_list}}]}
    }

    // if first_point_selected is false, proceed as if the dropdown is generated
    // to select the first point

    var options = [];
    var atom_index = this.dict["atom"];
    var sub_index = this.dict["subatom"];
    var inst_points = this.tree[selected_binding][atom_index][sub_index];
    var inst_point_id = inst_points[0]["id"];
    var that = this;

    var inst_points_list = [];
    for (var i=0; i<inst_points.length; i++){
      if (inst_points[i]["code_line"] == this.line){
        inst_points_list.push(inst_points[i]["id"]);
      }
    }

    // the options in the menu depend on the type of the atom that contains the selected subatom

    axios.get('/get_atom_type/'+atom_index+"/"+inst_point_id+"/").then(function(response){
      var atom_type = response.data;
      //console.log(atom_type);
      Store.type_of_atom = atom_type;
      if (atom_type == "simple"){
        //for a simple atom we now need all observations made at these points,
        //filtered by: calls, binding, atom, subatom
        //then we can calculate verdict severity for each of the observations
        var option = {text: 'Plot severity of observations from this point',
                      data: {action: "simple-severity-plot",
                             type : "severity",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
         var option = {text: 'Plot observations from this point',
                      data: {action: "simple-observation-plot",
                             type : "observation",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
        var option2 = {text: 'Highlight paths by average verdict severity',
                      data: {action: "simple-path",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option2);
      }
      else if (atom_type == "timeBetween" || atom_type == "mixed") {
        // we need the list of inst points that belong to the same atom, but other than the selected subatom
        var other_points_list = [];
        var subtree = that.tree[selected_binding][atom_index];
        for (subatom in subtree){
          if (subatom != sub_index){
            for (var i=0; i<subtree[subatom].length; i++){
              other_points_list.push({id: subtree[subatom][i]["id"],
                                      line: subtree[subatom][i]["code_line"]});
            }
          }
        }
        option = {text: 'Select this statement and highlight others that can form a pair',
                  data: {action: (atom_type=="timeBetween") ? "between-select" : "mixed-select",
                         type : (atom_type=="timeBetween") ? "between-select" : "mixed-select",
                         other_lines: other_points_list,
                         calls: Store.selected_calls,
                         binding: selected_binding,
                         atom: atom_index,
                         points: inst_points_list,
                         selected_line_numbers: [that.line]}};
        options.push(option);
      }
    })
    var return_data = {options: options};
    return return_data
  },
  methods: {
    selectOption: function(data){
      start_loading();
      if (data["action"] == "simple-severity-plot"){
        // set the plot data globally
        plot_data = data;
        // set the plot type
        Store.plot.type = "severity";
        // plot the data we just set
        generate_plot(this);
      }
      if (data["action"] == "simple-observation-plot"){
        // set the plot data globally
        plot_data = data;
        // set the plot type
        Store.plot.type = "observation";
        // plot the data we just set
        generate_plot(this);
      }
      if (data["action"] == "simple-path") {
        plot_data = data;
        plot_data["function_id"] = Store.selected_function_id;
        plot_data["type"] = "simple-path";
        Store.plot.type = "simple-path";
        path_highlight_mode_on = true;
        highlight_paths(this);
      }
      if (data["action"] == "between-select" || data["action"] == "mixed-select") {
        plot_data = data;
        Store.first_point_selected = true;
        Store.plot.type = data["action"].split("-")[0];
        var new_list = [];
        var between_or_mixed = Store.plot.type;
        for (var i=0; i<plot_data["other_lines"].length; i++){
          if (plot_data["other_lines"][i]["line"] == this.line){
            new_list.push(plot_data["other_lines"][i]["id"]);
          }
        }
        this.options = [{text: "Fix this point as the other one and plot observations",
                         data: {action: between_or_mixed + "-observation-plot",
                                  type : between_or_mixed + "-observation",
                                  new_points: new_list}},
                         {text: "Fix this point as the other one and plot severity",
                          data: {action: between_or_mixed + "-severity-plot",
                                  type : between_or_mixed + "-severity",
                                  new_points: new_list}},
                         {text: "Fix this point as the other one and highlight paths by severity",
                          data: {action: between_or_mixed + "-path",
                                 type : between_or_mixed + "-path",
                                 new_points: new_list}}];
        this.$emit("firstselected", data["other_lines"]);
      }
      else if (data["action"] == "between-observation-plot") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "between-observation";
        Store.plot.type = "between-observation";
        generate_plot(this);
      }
      else if (data["action"] == "between-severity-plot") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "between-severity";
        Store.plot.type = "between-severity";
        generate_plot(this);
      }
      else if (data["action"] == "mixed-observation-plot") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "mixed-observation";
        Store.plot.type = "mixed-observation";
        generate_plot(this);
      }
      else if (data["action"] == "mixed-severity-plot") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "mixed-severity";
        Store.plot.type = "mixed-severity";
        generate_plot(this);
      }
      else if (data["action"] == "between-path") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "between-path";
        plot_data["selected_line_numbers"].push(this.line);
        plot_data["function_id"] = Store.selected_function_id;
        Store.plot.type = "between-path";
        path_highlight_mode_on = true;
        highlight_paths(this);
      }
      else if (data["action"] == "mixed-path") {
        if (plot_data["points"].length == 1) {
          plot_data["points"] = plot_data["points"].concat(data["new_points"]);
        }
        if (plot_data["points"].length == 2) {
          plot_data["points"] = [plot_data["points"][0], data["new_points"][0]];
        }
        plot_data["type"] = "mixed-path";
        plot_data["selected_line_numbers"].push(this.line);
        plot_data["function_id"] = Store.selected_function_id;
        Store.plot.type = "mixed-path";
        path_highlight_mode_on = true;
        highlight_paths(this);
      }
      else if (data["action"] == "simple-path-plot" || data["action"] == "between-path-plot" || data["action"] == "mixed-path-plot") {
        // set the plot data globally
        //plot_data = data;
        Store.plot.type = data["type"];
        Store.plot.current_hash = path_plot_hash;
        console.log("plot data");
        console.log(data);
        generate_plot(this);
      }

      stop_loading();
    }
  },
  mounted(){
    var that = this;
    this.$root.$on("subatom-selected", function(dict){
      if (Store.type_of_atom){
      var options = [];
      var atom_index = dict["atom"];
      var sub_index = dict["subatom"];
      var inst_points = that.tree[selected_binding][atom_index][sub_index];
      var inst_point_id = inst_points[0]["id"];

      var inst_points_list = [];
      for (var i=0; i<inst_points.length; i++){
        if (inst_points[i]["code_line"] == that.line){
          inst_points_list.push(inst_points[i]["id"]);
        }
      }

      var atom_type = Store.type_of_atom;
      if (atom_type == "simple"){
        //for a simple atom we now need all observations made at these points,
        //filtered by: calls, binding, atom, subatom
        //then we can calculate verdict severity for each of the observations
        var option = {text: 'Plot severity of observations from this point',
                      data: {action: "simple-severity-plot",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
        var option = {text: 'Plot observations from this point',
                      data: {action: "simple-observation-plot",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option);
        var option2 = {text: 'Highlight paths by average verdict severity',
                      data: {action: "simple-path",
                             calls: Store.selected_calls,
                             binding: that.binding,
                             atom: atom_index,
                             subatom: sub_index,
                             points: inst_points_list}};
        options.push(option2);
      }
      else if (atom_type == "timeBetween" || atom_type == "mixed") {
        // we need the list of inst points that belong to the same atom, but other than the selected subatom
        var other_points_list = [];
        var subtree = that.tree[selected_binding][atom_index];
        for (subatom in subtree){
          if (subatom != sub_index){
            for (var i=0; i<subtree[subatom].length; i++){
              other_points_list.push({id: subtree[subatom][i]["id"],
                                      line: subtree[subatom][i]["code_line"]});
            }
          }
        }
        option = {text: 'Fix this point and select the other one',
                  data: {action: (atom_type=="timeBetween") ? "between-select" : "mixed-select",
                         type : (atom_type=="timeBetween") ? "between-select" : "mixed-select",
                         other_lines: other_points_list,
                         calls: Store.selected_calls,
                         binding: selected_binding,
                         atom: atom_index,
                         points: inst_points_list,
                         selected_line_numbers: [that.line]}};
        options.push(option);
      }
      that.options = options;}
    })

  }
})


Vue.component("plot", {
  template: `<div id="plot-wrapper" class="plot">
  <div id="plot-controls"><a href="#" @click="hidePlot($event)" class="close-plot">close</a></div>
  <div id="plot-new-window">
    <p><a href="#" @click="newPlotWindow($event)">Move to new window</a></p>
    <p><a href="#" @click="downloadPDF($event)">Download PDF</a></p>
  </div>
  <div id="plot-description" v-html="this.description"></div>
  <div id="path-filters" v-if="is_by_path_plot">Select path:
    <a v-for="(path, index) in paths" href="#"
      :class = "(index == store.chosen_path_index) ? 'filter active' : 'filter'"
      @click="choosePath($event, index)">Path Index {{index}}</a>
  </div>
  <p></p>
  <div id="plot-filters" v-if="is_severity_plot">Filters:
    <a href="#" id="violations" class="filter" v-bind:class="{active : violationFilterActive}"
      @click="toggleViolationFilter($event)">Violations</a>
    <a href="#" id="successes" class="filter" v-bind:class="{active : successFilterActive}"
      @click="toggleSuccessFilter($event)">Successes</a>
  </div>
  <p></p>
  <svg id="plot-svg"></svg>
  </div>`,
  data() {
    return {
      store : Store
    }
  },
  computed : {
    description : function() {
      if(this.store.plot.type == "severity" || this.store.plot.type == "between-severity" || this.store.plot.type == "mixed-severity") {
        return 'Plot of <span class="constraint">' + this.store.plot.constraint_html + "</span> severity";
      } else {
        return 'Plot of <span class="constraint">' + this.store.plot.constraint_html + "</span>";
      }
    },
    violationFilterActive : function() {
      return this.store.plot.show_violations;
    },
    successFilterActive : function() {
      return this.store.plot.show_successes;
    },
    is_severity_plot : function() {
      return this.store.plot.type == "severity" || this.store.plot.type == "between-severity" ||
             this.store.plot.type == "mixed-severity" || this.store.plot.type == "between-path-severity";
    },
    is_mixed_observation_plot : function() {
      return this.store.plot.type == "mixed-observation";
    },
    is_by_path_plot : function() {
      return this.store.plot.type == "between-path-severity" || this.store.plot.type == "between-path-observation";
    },
    paths : function() {
      return path_plot_data;
    }
  },
  mounted(){
    var that = this;
    this.$root.$on("calls-loaded", function(dict){
      if (!(plot_visible)) return
      // empty plot
      $("#plot-svg").empty();
      // toggle visibility
      $("#plot-wrapper").removeClass("show");
      // set the global flag
      plot_visible = false;
    })
    this.$root.$on("plot-data-ready", function(data_array){
      // display the plot
      $("#plot-wrapper").addClass("show");
      // set height of plot wrapper
      $("#plot-wrapper").height(
        $(".panel.panel-success.function-calls").outerHeight() -
        $(".panel.panel-success.code-view").find(".panel-heading").first().outerHeight() -
        $("#specification_listing").outerHeight());
      $("#plot-svg").width($("#code-listing").outerWidth());
      if(that.store.plot.type == "severity") {
          $("#plot-svg").height($("#plot-wrapper").outerHeight() - $("#plot-controls").outerHeight()
                                - $("#plot-description").outerHeight()
                                - $("#plot-filters").outerHeight());
      } else {
          $("#plot-svg").height($("#plot-wrapper").outerHeight() - $("#plot-controls").outerHeight()
                                - $("#plot-description").outerHeight());
      }
      //var data_array = data["array"];
      nv.addGraph(function() {
        var chart = nv.models.multiBarChart()
          .x(function(d) { return d.label })
          .y(function(d) { return d.value })
          .reduceXTicks(true)    //alternatively, use staggering or rotated labels to prevent overlapping
          .showControls(false)   //Allow user to switch between 'Grouped' and 'Stacked' mode.
          .showLegend(that.is_mixed_observation_plot)
          .color(["#2b5fed", "#f5b52c"])

        // omitting date from time format - moslty the difference is in seconds
        var y_label = that.is_severity_plot ? 'Verdict severity' : 'Observation';
        chart.xAxis
          .axisLabel('Time of observation')
          .tickFormat(function(d) { return d3.time.format('%H:%M:%S')(new Date(d)); });
        chart.yAxis
          .axisLabel(y_label)
          .tickFormat(d3.format('.02f'))
          .showMaxMin(true);

        chart.tooltip(function(key, x, y, e, graph) {
          return x + " -> " + y;
        });

        d3.select('#plot-svg')
          .datum(data_array)
          .call(chart);

        nv.utils.windowResize(chart.update);

        // set initial size
        chart.update();

        stop_loading();

        return chart;
      });
    })
  },
  methods:{
    hidePlot: function(e){
      // prevent navigation that would normally take place when a link is clicked
      e.preventDefault();
      // empty plot
      $("#plot-svg").empty();
      // toggle visibility
      $("#plot-wrapper").toggleClass("show");
      // set the global flag
      plot_visible = false;
    },
    newPlotWindow : function(e) {
      e.preventDefault();
      $("#plot-svg").empty();
      $("#plot-wrapper").toggleClass("show");
      plot_visible = false;
      window.open("/display_plot/" + this.store.plot.current_hash, "plot", "height=500,width=900");
    },
    downloadPDF : function(e) {
      e.preventDefault();
      window.location = "/download_plot/" + this.store.plot.current_hash;
    },
    toggleSuccessFilter : function(e) {
      e.preventDefault();
      this.store.plot.show_successes = !this.store.plot.show_successes;
      generate_plot(this);

    },
    toggleViolationFilter : function(e) {
      e.preventDefault();
      this.store.plot.show_violations = !this.store.plot.show_violations;
      generate_plot(this);
    },
    choosePath : function(e, index) {
      e.preventDefault();
      this.store.chosen_path_index = index;
      generate_plot(this);
    }
  }

})


Vue.component("path-code", {
  props: ["code", "start"],
  template: `<div id="path-wrapper" class="path">
  <div id="path-controls"><a href="#" @click="hidePath($event)" class="close-path">close</a></div>
    <div v-if="code_lines" class='code_listing'>
      <div v-for="(line,index) in code_lines" :key="index" :class="line.class"
      :id="line.id" :style="line.background" :save-background-color="line.color"
      v-show="line.show">
        <b> {{line.line_number}} </b>
        <span class="language-python" v-html="line.content"> </span>
      </div>
    </div>
  </div>`,
  data() {
    return {
      store : Store,
      code_lines: this.code,
      start_line: this.start
    }
  },
  mounted(){
    var that = this;
    this.$root.$on('path-data-ready', function(data_ready){
      var whole_code = JSON.parse(JSON.stringify(that.code));
      for (var i=0; i<whole_code.length; i++) {
        if ((that.start + i) >= data_ready["first_line"] &&
            (that.start + i) <= data_ready["last_line"]) {
          whole_code[i].show = true;
        } else {
          whole_code[i].show = false;
        }
      }

      console.log(data_ready);

      for (var i=0; i<data_ready["lines_to_colors"].length; i++) {
        var dict = data_ready["lines_to_colors"][i];
        for (var j=0; j<dict["lines"].length; j++) {
          console.log(dict["color"])
          whole_code[dict["lines"][j]-that.start].background = "background-color: " + dict["color"];
        }
      }

      for (var i=0; i<data_ready["main_lines"].length; i++) {
        whole_code[data_ready["main_lines"][i]-that.start].background = "background-color: #cce0ff";
      }

      that.code_lines = whole_code;
      $("#path-wrapper").addClass("show");
    })


  },
  methods:{
    hidePath: function(e){
      // prevent navigation that would normally take place when a link is clicked
      e.preventDefault();
      // toggle visibility
      $("#path-wrapper").toggleClass("show");
      // set the global flag
      path_visible = false;
    }
  }

})


var app = new Vue({
    el : "#app"
});
